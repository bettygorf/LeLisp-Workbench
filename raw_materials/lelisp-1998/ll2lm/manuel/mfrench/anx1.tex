%===================================================================
\Chapter {1}{Exemple complet}
%===================================================================

Nous allons illustrer l'utilisation de l'{\it analyseur de modules} au
travers d'un exemple simple. Pour cela, nous avons \'{e}crit notre
application sous forme de 3 fichiers {\tt bar.ll, foo.ll} et {\tt
gee.ll}. Puis, nous devons d\'{e}crire notre application sous forme d'un
projet que nous appelerons "myappli". Les modules et leur
compilation seront stock\'{e}s dans le
r\'{e}pertoire {\tt /tmp/modules/}.
Les 3 fichiers source, dans le r\'{e}pertoire {\tt /tmp/} sont\,:
\begin{itemize}
\item {\tt bar.ll}
\begin{Code*}
(defun bar (x) 
  (print "Hello, I am " x))
\end{Code*}
\item {\tt foo.ll}
\begin{Code*}
(defun foo (a b)
   (bar (catenate a b)))
\end{Code*}
\item {\tt gee.ll}
\begin{Code*}
(defun do-it ()
   (let* ((name (ask-string "Name" () t))
          (firstname (and name (ask-string "First name" () t))))
     (when name
           (foo name (or firstname " ??? ")))))
\end{Code*}
\end{itemize}
Nous passosn \`{a} la d\'{e}finition du projet {\tt myappli}. 

Nous avons essay\'{e} d'\^{e}tre
exhaustifs dans cette d\'{e}finition de projet, mais les nombreuses lignes
en commentaire ({\tt ; ...}) montrent que nombre de clefs peuvent
\^{e}tre omises. \\
L'ent\^{e}te de la d\'{e}finition du projet et les pr\'{e}requis\,:
\begin{Code*}
;; pour charger les contextes AIDA et LELISP, utilise's par myappli
^L/usr/ilog/lelisp/modana/lisp.prj
^L/usr/ilog/aida/modana/aida.prj

(define-rt-project myappli ...)
\end{Code*}

Il n'y a pas d'ordre impos\'{e} pour les clefs. On commence ici par les
projets requis.

Les autres projets utilis\'{e}s (on commente cette ligne dans un premier
temps afin d'en observer les cons\'{e}quences)\,:
\begin{Code*}
        ; required-projects (aida)
\end{Code*}

D\'{e}crivons maintenant l'ensemble des r\'{e}pertoires du projet.

Tout d'abord la racine des autres repertoires\,:
\begin{Code*}
        root-directory #u"/tmp/"
\end{Code*}
La liste des r\'{e}pertoires contenant les fichiers source de l'application\,:
\begin{Code*}
        directories ("/tmp/")
\end{Code*}

Le r\'{e}pertoire o\`{u} ranger le fichier des r\'{e}f\'{e}rences de l'application
(par d\'{e}faut {\tt crunch-directory} == {\tt root-directory})\,:
\begin{Code*}
        crunch-directory "./modana/" 
\end{Code*}

Le r\'{e}pertoire o\`{u} ranger les fichiers syst\`{e}mes comme les {\tt
Makefiles} (par d\'{e}faut {\tt system-directory} == {\tt
root-directory})\,: 
\begin{Code*}
        system-directory "./modana/" 
\end{Code*}

Le r\'{e}pertoire o\`{u} ranger les modules
(par d\'{e}faut chaque module est \`{a} c\^{o}t\'{e} de son source)\,:
\begin{Code*}
        ll-module-directory #u"./modules/"
\end{Code*}

Le r\'{e}pertoire o\`{u} ranger les fichiers objets
(par d\'{e}faut {\tt ll-object-directory} == {\tt ll-module-directory})\,:
\begin{Code*}
        ; ll-object-directory #u"./modules/"
\end{Code*}

On d\'{e}finit maintenant les noms des fichiers utilis\'{e}s.\\

On commence par le pr\'{e}sent fichier\,: celui qui contient la
d\'{e}finition du projet (par d\'{e}faut {\tt system-directory/myappli.prj})\,:
\begin{Code*}
        ; project-file myappli.prj
\end{Code*}

Le nom du {\tt Makefile} d'analyse (par d\'{e}faut {\tt
system-directory/myappli.mki})\,:
\begin{Code*}
        ; init-makefile myappli.mki
\end{Code*}

Le nom du {\tt Makefile} de compilation (par d\'{e}faut {\tt
system-directory/myappli.mk})\,: 
\begin{Code*}
        ; make-file myappli.mk
\end{Code*}

Le nom du fichier des r\'{e}f\'{e}rences (par d\'{e}faut {\tt
crunch-directory/myappli.ref})\,: 
\begin{Code*}
        ; ref-file myappli.ref
\end{Code*}

On peut \'{e}galement d\'{e}finir les options d'analyse et de compilation.

Les options d'analyse\,:
\begin{Code*}
        analyzer-options ((gee "-verbose 2"))
\end{Code*}

Les flags de compilation\,:
\begin{Code*}
        complice-options (("all" "-parano t"))
\end{Code*}


La toute premi\`{e}re \'{e}tape consiste \`{a} fabriquer le {\tt Makefile}
d'initialisation Avec l'option \|-init| de l'{\em Analyseur de Modules}:
\begin{Code*}
unix% ll2lm -load myappli.prj -p myappli -init
\end{Code*}
Cette commande a g\'{e}n\'{e}r\'{e} un nouveau {\tt Makefile} dans le
r\'{e}pertoire {\tt modana}\,:
\begin{Longcode*}
unix% ls -R
bar.ll
foo.ll
gee.ll
modana/myappli.mki
modana/myappli.prj
modules/
\end{Longcode*}
On peut oberver le contenu de ce {\tt Makefile}\,:
\begin{Longcode*}
# This makefile was generated by the ILOG Analyzer.
# Version     : 2.0         Date : Tue Nov  16 93 11:18:14
# SubVersion  : 2
# It enables to build modules from Lisp source files for
# - project : myappli
#
######
# Directories
######

ROOTDIR=/tmp/
CRUNCHDIR=/tmp/modana/
LLDIR=/usr/ilog/lelisp/

######
# Makefile's environment
######

SYSTEM=sun4
MAKE=make -f /tmp/myappli.mki
PROJECTNAME=myappli
PROJECTFILE=/tmp/myappli.prj

######
# Analyzer's options
######

ANALYZE=ll2lm
OUTPUT=
FILEOPTION=-v 1 -update $$FILELM
USEROPTIONS=
ANALYZEOPTIONS=-load $(PROJECTFILE) -p $(PROJECTNAME) $(OUTPUT) $(USEROPTIONS)
######
# LL Objects involved
######

LLOBJS=/tmp/modules/foo.lm /tmp/modules/bar.lm \
        /tmp/modules/gee.lm

######
# Generic entries
######

all : $(LLOBJS)

scratch : init1 init2 update make

init1 : clean
        $(MAKE) all FILEOPTION="-defmodule \$$\$$MODNAME -o \$$\$$FILELM"
        @touch init1

init2 :
        $(MAKE) all FILEOPTION="-defmodule \$$\$$MODNAME -o \$$\$$FILELM"
        @touch init2

update : init2
        $(MAKE) all FILEOPTION="-v 1 -update \$$\$$FILELM"
        @touch update

make : update /tmp/myappli.mk

/tmp/myappli.mk : $(LLOBJS)
        $(ANALYZE) $(ANALYZEOPTIONS) -makefile

cleanobj :
        rm -f $(LLOBJS)

cleanfiles :
        rm -f /tmp/myappli.ref
        rm -f /tmp/myappli.mk

clean : cleanobj cleanfiles
        @rm -f init1 init2 update


info :

work :

######
# ANALYZER dependencies
######

/tmp/modules/foo.lm foo.lm  :  work /tmp/foo.ll
        ( MODNAME=foo;  FILELM=/tmp/modules/foo.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) )

/tmp/modules/bar.lm bar.lm  :  work /tmp/bar.ll
        ( MODNAME=bar;  FILELM=/tmp/modules/bar.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) )

/tmp/modules/gee.lm gee.lm  :  work /tmp/gee.ll
        ( MODNAME=gee;  FILELM=/tmp/modules/gee.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) -verbose 2 )
\end{Longcode*}


L'\'{e}tape suivante consiste \`{a} commencer l'analyse, de fa\c{c}on \`{a}
r\'{e}cup\'{e}rer les commentaires de l'{\em Analyseur de Modules}, et
\'{e}ventuellement intervenir afin de corriger ces commentaires.\\
On utilisera donc les entr\'{e}es d'initialisation du {\tt Makefile} d'analyse:
la premi\`{e}re passe ({\tt init1}) permet de fabriquer les tables
internes, la seconde 
({\tt init2}) permet d'analyser l'ensemble des modules du projet avec
les tables construites. Premi\`{e}re phase\,:
\begin{Longcode*}
unix% make -f myappli.mki init1
 ...
 (ne pas tenir compte de ces commentaires, sauf erreur grave)
 ...
\end{Longcode*}
On note \`{a} partir de l\`{a} l'existence du fichier {\tt myappli.ref}
contenant toutes les informations relatives aux modules et \`{a} leurs
d\'{e}pendances. 
\begin{Longcode*}
unix% ls modana
modana/myappli.mki
modana/myappli.prj
modana/myappli.ref
\end{Longcode*}

Passons \`{a} la deuxi\`{e}me phase d'initialisation (on notera que seul
{\tt gee} est analys\'{e} en mode \|verbose|):
\begin{Longcode*}
unix% make -f myappli.mki init2
make -f /tmp/myappli.mki all FILEOPTION="-defmodule \$\$MODNAME -o \$\$FIL
ELM"
( MODNAME=foo;  FILELM=/tmp/modules/foo.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 )
;;; Tu utilises l'ANALYSEUR de Le-Lisp
( MODNAME=bar;  FILELM=/tmp/modules/bar.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 )
;;; Tu utilises l'ANALYSEUR de Le-Lisp
( MODNAME=gee;  FILELM=/tmp/modules/gee.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 -verbose 2 )
;;; Tu utilises l'ANALYSEUR de Le-Lisp
>>>>> verbose mode level = 2

=====
===== STEP 1 : loading context of project : myappli
=====
.. reading file(s) : #p"/tmp/myappli.ref"
.. reading file(s) : #p"/tmp/myappli.ref"

=====
===== STEP 2 : browsing files of module : gee
=====          involved files are : (gee.ll)
=====
.. reading file(s) : (gee.ll)
.. scanning functions : ...
** W.101 : unknown function : I can't find it anywhere : ask-string
** W.101 : unknown function : I can't find it anywhere : ask-string
.. unknown function foo - it's exported by module : (foo)
.. evaluating CPENV field of module : bar
.. evaluating CPENV field of module : foo

=====
===== STEP 3 : diagnostic
=====

===== Concerning IMPORTS :
--
-- The following are undefined function
--      ask-string
--      ask-string
--
-- Modules defining these entities have to be analyzed before module: gee
-- If these entities are defined in ILOG products, please specify
-- the correct context(s) for analysis.


- You have to import "foo" because of :
 foo .

===== Concerning EXPORTS :
- The following functions will be unused unless exported :
     do-it

=====
===== STEP 4 : updating module description : #p"/tmp/modules/gee.lm"
=====
.. Previous file #p"/tmp/modules/gee.lm" saved in :
#p"/tmp/modules/gee.lm~"
.. updating module description file : #p"/tmp/modules/gee.lm"

=====
===== STEP 4bis : updating reference file : #p"/tmp/myappli.ref"
=====
.. reading file(s) : #p"/tmp/myappli.ref"
.. no need to rewrite file : #p"/tmp/myappli.ref"

\end{Longcode*}

Il apparait clairement (il manque {\tt ask-string})
que nous avons oubli\'{e} de pr\'{e}ciser que nous
utilisions le projet AIDA lors de la d\'{e}finition du projet {\tt myappli}.
Il suffit donc d'ajouter la ligne:
\begin{Longcode*}
(define-rt-project myappli
         ...
        required-project (aida)
         ...
)
\end{Longcode*}
Il conviendra ensuite de relancer le {\tt Makefile} d'analyse, en mode
\|update| cette fois:
\begin{Longcode*}
unix% make -f myappli.mki update
\end{Longcode*}
ou plus simplement
\begin{Longcode*}
unix% make -f myappli.mki
\end{Longcode*}
Une nouvelle exploration des r\'{e}pertoires du projet nous montre les
nouveaux fichiers\,:
\begin{Longcode*}
unix% ls /tmp/*
bar.ll
foo.ll
gee.ll
init1
init2
modana/myappli.mki
modana/myappli.prj
modana/myappli.ref
modules/bar.lm
modules/bar.lm~
modules/foo.lm
modules/foo.lm~
modules/gee.lm
modules/gee.lm~
\end{Longcode*}

On peut regarder comment est fait un fichier des r\'{e}f\'{e}rences\,:


\begin{Longcode*}
projectname
myappli
modulesimport
((gee foo aida) (bar) (foo bar))
modulesexport
((gee do-it) (bar bar) (foo foo))
modulesotherdef
()
modulesinternal
()
\end{Longcode*}


Une fois que tous les modules du projet sont analys\'{e}s sans
avertissement, nous allons vouloir les compiler avec {\tt complice}.
Pour cela nous allons fabriquer un {\tt Makefile} avec l'option \|-makefile|
de l'{\em Analyseur de Modules}:
\begin{Longcode*}
unix% ll2lm -load myappli.prj -p myappli -makefile
\end{Longcode*}
Un nouveau {\tt Makefile} est g\'{e}n\'{e}r\'{e} pour la compilation\,:

\begin{Longcode*}
# This makefile was generated by the ILOG Analyzer.
# Version     : 2.06         Date : Tue Nov  16 93 11:52:43
# SubVersion  : 1
# It enables to build modules from Lisp source files for
# - project : myappli
#
######
# Directories
######

ROOTDIR=/tmp/
SYSTEM=sun4
LLDIR=/usr/ilog/lelisp/
LLOBJDIR=/tmp/modules/
LLMODDIR=/tmp/modules/

######
# Make use of standard complice
######

COMPLICE=/usr/ilog/lelisp/$(SYSTEM)/complice

######
# Complice options
######

COMPLICEFLAGS=\
        -e "(set (symbol (quote system)(quote path)) (list  \
        \"/tmp/modules/\" \"/tmp/\" ))" -parano t

######
# LL Objects involved
######

LLOBJS=$(LLOBJDIR)gee.lo $(LLOBJDIR)bar.lo $(LLOBJDIR)foo.lo

######
# Generic entries
######

all: $(LLOBJS)

clean:
        rm -f $(LLOBJS)


info:
        @echo complice=$(COMPLICE)
        @echo compliceflags=$(COMPLICEFLAGS)

i:
        @$(COMPLICE) $(COMPLICEFLAGS) -v -i

######
# Module dependencies
######

$(LLOBJDIR)gee.lo : $(LLMODDIR)gee.lm /tmp/gee.ll \
        $(LLMODDIR)foo.lm
        $(COMPLICE) gee $(COMPLICEFLAGS) -o $(LLOBJDIR)

$(LLOBJDIR)bar.lo : $(LLMODDIR)bar.lm /tmp/bar.ll
        $(COMPLICE) bar $(COMPLICEFLAGS) -o $(LLOBJDIR)

$(LLOBJDIR)foo.lo : $(LLMODDIR)foo.lm /tmp/foo.ll \
        $(LLMODDIR)bar.lm
        $(COMPLICE) foo $(COMPLICEFLAGS) -o $(LLOBJDIR)
\end{Longcode*}


On peut lancer ce {\tt Makefile} pour compiler tous les modules de
l'application\,:
\begin{Longcode*}
unix% make -f myappli.mk
/usr/ilog/lelisp/sun4/complice gee -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
Que Le-Lisp soit avec vous.
/usr/ilog/lelisp/sun4/complice bar -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
Que Le-Lisp soit avec vous.
/usr/ilog/lelisp/sun4/complice foo -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
Que Le-Lisp soit avec vous.
\end{Longcode*}

On peut v\'{e}rifier que les fichiers sont bien rang\'{e}s dans le
r\'{e}pertoire {\tt /tmp/modules/}:
\begin{Longcode*}
unix% ls modules/*
modules/bar.lm
modules/bar.lo
modules/foo.lm
modules/foo.lo
modules/gee.lm
modules/gee.lo
\end{Longcode*}


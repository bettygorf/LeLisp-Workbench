%===================================================================
\Chapter {1}{A Complete Example}
%===================================================================

We are going to illustrate the use of the {\it module analyzer} by using a simple example.  To do this, we have written our applications in the form of three files {\tt bar.ll, foo.ll}, and {\tt
gee.ll}.  We now must write our application in the form of a project that we will call {\tt myappli}.  The modules and their compilation will be stored in the {\tt /tmp/modules/} directory.
The three source files in the {\tt /tmp/} directory are:
\begin{itemize}
\item {\tt bar.ll}
\begin{Code*}
(defun bar (x) 
  (print "Hello, I am " x))
\end{Code*}
\item {\tt foo.ll}
\begin{Code*}
(defun foo (a b)
   (bar (catenate a b)))
\end{Code*}
\item {\tt gee.ll}
\begin{Code*}
(defun do-it ()
   (let* ((name (ask-string "Name" () t))
          (firstname (and name (ask-string "First name" () t))))
     (when name
           (foo name (or firstname " ??? ")))))
\end{Code*}
\end{itemize}
We move now to the definition of the project {\tt myappli}.

We have tried to be exhaustive in this project definition but the numerous
comment lines ({\tt ; ...}) show that a number of keys can be omitted.
The header of the project definition and the prerequisites:
\begin{Code*}
;; to load the AIDA and LELISP contexts used by myappli
^L/usr/ilog/lelisp/modana/lisp.prj
^L/usr/ilog/aida/modana/aida.prj

(define-rt-project myappli ...)
\end{Code*}

There is no order imposed for the keys.  You begin here with the required projects.

The other projects used (you comment this line initially to see, in fact, the consequences of commenting this line): 
\begin{Code*}
        ; required-projects (aida)
\end{Code*}

We describe here the ensemble of project directories.

First the root of the other directories:
\begin{Code*}
        root-directory #u"/tmp/"
\end{Code*}
The list of the directories containing the source files of the application:
\begin{Code*}
        directories ("/tmp/")
\end{Code*}

The directory where the the reference files of the application are organized (by default {\tt crunch-directory} == {\tt root-directory}):
\begin{Code*}
        crunch-directory "./modana/" 
\end{Code*}

The directory where the system files are organzied as well as the {\tt
Makefiles} (by default {\tt system-directory} == {\tt
root-directory}):
\begin{Code*}
        system-directory "./modana/" 
\end{Code*}

The directory where the modules are organized (by default each module is next to its source):
\begin{Code*}
        ll-module-directory #u"./modules/"
\end{Code*}

The directory where the object files are organized (by default {\tt ll-object-directory} == {\tt ll-module-directory}):
\begin{Code*}
        ; ll-object-directory #u"./modules/"
\end{Code*}

We define next the files names that are used.

We begin by the current file:  that file that contains the project definition (by default {\tt system-directory/myappli.prj}):
\begin{Code*}
        ; project-file myappli.prj
\end{Code*}

The name of the analysis {\tt Makefile} (by default {\tt
system-directory/myappli.mki}):
\begin{Code*}
        ; init-makefile myappli.mki
\end{Code*}

The name of the compilation {\tt Makefile} (by default {\tt
system-directory/myappli.mk}):
\begin{Code*}
        ; make-file myappli.mk
\end{Code*}

The name of the reference file (by default {\tt
crunch-directory/myappli.ref}):
\begin{Code*}
        ; ref-file myappli.ref
\end{Code*}

You can also define the analysis options and compilation options.

The analysis options:
\begin{Code*}
        analyzer-options ((gee "-verbose 2"))
\end{Code*}

The compilation flags:
\begin{Code*}
        complice-options (("all" "-parano t"))
\end{Code*}

The very first step consists of creating the initialization {\tt Makefile} with the \|-init| option of the {\em Module Analyzer}:
\begin{Code*}
unix% ll2lm -load myappli.prj -p myappli -init
\end{Code*}
This command generates a new {\tt Makefile} in the {\tt modana} directory:
\begin{Longcode*}
unix% ls -R
bar.ll
foo.ll
gee.ll
modana/myappli.mki
modana/myappli.prj
modules/
\end{Longcode*}
You can observe the contents of this {\tt Makefile}:
\begin{Longcode*}
# This makefile was generated by the ILOG Analyzer.
# Version     : 2.0         Date : Tue Nov  16 93 11:18:14
# SubVersion  : 2
# It enables you to build modules from Lisp source files for
# - project : myappli
#
######
# Directories
######

ROOTDIR=/tmp/
CRUNCHDIR=/tmp/modana/
LLDIR=/usr/ilog/lelisp/

######
# Makefile's environment
######

SYSTEM=sun4
MAKE=make -f /tmp/myappli.mki
PROJECTNAME=myappli
PROJECTFILE=/tmp/myappli.prj

######
# Analyzer's options
######

ANALYZE=ll2lm
OUTPUT=
FILEOPTION=-v 1 -update $$FILELM
USEROPTIONS=
ANALYZEOPTIONS=-load $(PROJECTFILE) -p $(PROJECTNAME) $(OUTPUT) $(USEROPTIONS)
######
# LL Objects involved
######

LLOBJS=/tmp/modules/foo.lm /tmp/modules/bar.lm \
        /tmp/modules/gee.lm

######
# Generic entries
######

all : $(LLOBJS)

scratch : init1 init2 update make

init1 : clean
        $(MAKE) all FILEOPTION="-defmodule \$$\$$MODNAME -o \$$\$$FILELM"
        @touch init1

init2 :
        $(MAKE) all FILEOPTION="-defmodule \$$\$$MODNAME -o \$$\$$FILELM"
        @touch init2

update : init2
        $(MAKE) all FILEOPTION="-v 1 -update \$$\$$FILELM"
        @touch update

make : update /tmp/myappli.mk

/tmp/myappli.mk : $(LLOBJS)
        $(ANALYZE) $(ANALYZEOPTIONS) -makefile

cleanobj :
        rm -f $(LLOBJS)

cleanfiles :
        rm -f /tmp/myappli.ref
        rm -f /tmp/myappli.mk

clean : cleanobj cleanfiles
        @rm -f init1 init2 update


info :

work :

######
# ANALYZER dependencies
######

/tmp/modules/foo.lm foo.lm  :  work /tmp/foo.ll
        ( MODNAME=foo;  FILELM=/tmp/modules/foo.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) )

/tmp/modules/bar.lm bar.lm  :  work /tmp/bar.ll
        ( MODNAME=bar;  FILELM=/tmp/modules/bar.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) )

/tmp/modules/gee.lm gee.lm  :  work /tmp/gee.ll
        ( MODNAME=gee;  FILELM=/tmp/modules/gee.lm;  \
        $(ANALYZE) $(FILEOPTION) $(ANALYZEOPTIONS) -verbose 2 )
\end{Longcode*}

The following step consists of starting the analysis in a way that will allow you to recover comments from the {\em Module Analyzer} so you might, eventually, correct these comments.  You will use the initialization entries of the analysis {\tt Makefile}:
the first pass ({\tt init1}) allows you to create the internal tables, the second pass ({\tt init2}) allows you to analyze the ensemble of the project modules with the constructed tables.  First phase:

\begin{Longcode*}
unix% make -f myappli.mki init1
 ...
 (pay no attention to the generated comments unless they are especially grave)
 ...
\end{Longcode*}

You should note the existence of the {\tt myappli.ref} file that contains all the information relative to the modules and to their dependencies. 
\begin{Longcode*}
unix% ls modana
modana/myappli.mki
modana/myappli.prj
modana/myappli.ref
\end{Longcode*}

Let's move now to the second initialization phase (you will note that only {\tt gee} is analyzed in \|verbose| mode):

\begin{Longcode*}
unix% make -f myappli.mki init2
make -f /tmp/myappli.mki all FILEOPTION="-defmodule \$\$MODNAME -o \$\$FIL
ELM"
( MODNAME=foo;  FILELM=/tmp/modules/foo.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 )
;;; You use the Le-Lisp Analyzer
( MODNAME=bar;  FILELM=/tmp/modules/bar.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 )
;;; You use the Le-Lisp Analyzer
( MODNAME=gee;  FILELM=/tmp/modules/gee.lm;  \
ll2lm -defmodule $MODNAME -o $FILELM -load /tmp/myappli.prj -p myappli
 -verbose 2 )
;;; You use the Le-Lisp Analyzer
>>>>> verbose mode level = 2

=====
===== STEP 1 : loading context of project : myappli
=====
.. reading file(s) : #p"/tmp/myappli.ref"
.. reading file(s) : #p"/tmp/myappli.ref"

=====
===== STEP 2 : browsing files of module : gee
=====          involved files are : (gee.ll)
=====
.. reading file(s) : (gee.ll)
.. scanning functions : ...
** W.101 : unknown function : I can't find it anywhere : ask-string
** W.101 : unknown function : I can't find it anywhere : ask-string
.. unknown function foo - it's exported by module : (foo)
.. evaluating CPENV field of module : bar
.. evaluating CPENV field of module : foo

=====
===== STEP 3 : diagnostic
=====

===== Concerning IMPORTS :
--
-- The following are undefined functions
--      ask-string
--      ask-string
--
-- Modules defining these entities have to be analyzed before module: gee
-- If these entities are defined in ILOG products, please specify
-- the correct context(s) for analysis.


- You have to import "foo" because of :
 foo .

===== Concerning EXPORTS :
- The following functions will be unused unless exported :
     do-it

=====
===== STEP 4 : updating module description : #p"/tmp/modules/gee.lm"
=====
.. Previous file #p"/tmp/modules/gee.lm" saved in :
#p"/tmp/modules/gee.lm~"
.. updating module description file : #p"/tmp/modules/gee.lm"

=====
===== STEP 4bis : updating reference file : #p"/tmp/myappli.ref"
=====
.. reading file(s) : #p"/tmp/myappli.ref"
.. no need to rewrite file : #p"/tmp/myappli.ref"
\end{Longcode*}

It should be apparent ({\tt ask-string} is missing) that we have forgotten to specify that we use the AIDA project at the time of the project definition {\tt myappli}.  It is necessary, then, to add the line:

\begin{Longcode*}
(define-rt-project myappli
         ...
        required-project (aida)
         ...
)
\end{Longcode*}

It is also a good idea to restart the analysis {\tt Makefile} in \|update| mode this time:
\begin{Longcode*}
unix% make -f myappli.mki update
\end{Longcode*}
or even easier
\begin{Longcode*}
unix% make -f myappli.mki
\end{Longcode*}
A new look at the project directories show the new files:
\begin{Longcode*}
unix% ls /tmp/*
bar.ll
foo.ll
gee.ll
init1
init2
modana/myappli.mki
modana/myappli.prj
modana/myappli.ref
modules/bar.lm
modules/bar.lm~
modules/foo.lm
modules/foo.lm~
modules/gee.lm
modules/gee.lm~
\end{Longcode*}

You can see what a reference file is made up of:

\begin{Longcode*}
projectname
myappli
modulesimport
((gee foo aida) (bar) (foo bar))
modulesexport
((gee do-it) (bar bar) (foo foo))
modulesotherdef
()
modulesinternal
()
\end{Longcode*}

Once all the project modules are analyzed without generating any warning messages, you are going to want to compile the project modules with {\tt complice}.
To do this you are going to create a {\tt Makefile} with the \|-makefile| option of the {\em Module Analyzer}:

\begin{Longcode*}
unix% ll2lm -load myappli.prj -p myappli -makefile
\end{Longcode*}

A new {\tt Makefile} is generated for the compilation:

\begin{Longcode*}
# This makefile was generated by the ILOG Analyzer.
# Version     : 2.06         Date : Tue Nov  16 93 11:52:43
# SubVersion  : 1
# It enables to build modules from Lisp source files for
# - project : myappli
#
######
# Directories
######

ROOTDIR=/tmp/
SYSTEM=sun4
LLDIR=/usr/ilog/lelisp/
LLOBJDIR=/tmp/modules/
LLMODDIR=/tmp/modules/

######
# Make use of standard complice
######

COMPLICE=/usr/ilog/lelisp/$(SYSTEM)/complice

######
# Complice options
######

COMPLICEFLAGS=\
        -e "(set (symbol (quote system)(quote path)) (list  \
        \"/tmp/modules/\" \"/tmp/\" ))" -parano t

######
# LL Objects involved
######

LLOBJS=$(LLOBJDIR)gee.lo $(LLOBJDIR)bar.lo $(LLOBJDIR)foo.lo

######
# Generic entries
######

all: $(LLOBJS)

clean:
        rm -f $(LLOBJS)


info:
        @echo complice=$(COMPLICE)
        @echo compliceflags=$(COMPLICEFLAGS)

i:
        @$(COMPLICE) $(COMPLICEFLAGS) -v -i

######
# Module dependencies
######

$(LLOBJDIR)gee.lo : $(LLMODDIR)gee.lm /tmp/gee.ll \
        $(LLMODDIR)foo.lm
        $(COMPLICE) gee $(COMPLICEFLAGS) -o $(LLOBJDIR)

$(LLOBJDIR)bar.lo : $(LLMODDIR)bar.lm /tmp/bar.ll
        $(COMPLICE) bar $(COMPLICEFLAGS) -o $(LLOBJDIR)

$(LLOBJDIR)foo.lo : $(LLMODDIR)foo.lm /tmp/foo.ll \
        $(LLMODDIR)bar.lm
        $(COMPLICE) foo $(COMPLICEFLAGS) -o $(LLOBJDIR)
\end{Longcode*}


You can start this {\tt Makefile} to compile all the modules of the application:
\begin{Longcode*}
unix% make -f myappli.mk
/usr/ilog/lelisp/sun4/complice gee -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
May Le-Lisp be with you.
/usr/ilog/lelisp/sun4/complice bar -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
May Le-Lisp be with you. 
/usr/ilog/lelisp/sun4/complice foo -e "(set (symbol (quote system)(quote path))
(list   \"/tmp/modules/\" \"/tmp/\" ))" -parano t -o /tmp/modules/
May Le-Lisp be with you. 
\end{Longcode*}

You can verify that the files are organized in the {\tt /tmp/modules/} directory:
\begin{Longcode*}
unix% ls modules/*
modules/bar.lm
modules/bar.lo
modules/foo.lm
modules/foo.lo
modules/gee.lm
modules/gee.lo
\end{Longcode*}


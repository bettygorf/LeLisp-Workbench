(loader '((title |foo.lo|)))
(loader'((fentry f-bar5 subr0)
(entry f-bar5 subr0)
(mov nil a1)
(return)
))
(loader'((entry f-too99 subr0)
(mov nil a1)
(return)
))
(loader'((entry #:bar:a-bar1:asd:f-bar2 subr1)
(return)
))
(loader'((fentry f-foo0 subr1)
(entry f-foo0 subr1)
(return)
))
(loader'((fentry f-foo1 subr1)
(entry f-foo1 subr1)
(jmp f-bar1)
))
(loader'((fentry f-foo1-10 subr0)
(entry f-foo1-10 subr0)
(mov '10 a1)
(return)
))
(loader'((fentry f-foo2-11 subr0)
(entry f-foo2-11 subr0)
(mov '11 a1)
(return)
))
(loader'((fentry f-foo3-12 subr0)
(entry f-foo3-12 subr0)
(mov '0 a1)
(jcall f-bar20)
(jmp f-bar2)
))
(loader'((fentry f-foo4-13 subr0)
(entry f-foo4-13 subr0)
(mov '13 a1)
(return)
))
(loader'((fentry m-bar1-f-foo-14 subr0)
(entry m-bar1-f-foo-14 subr0)
(mov '"f-foo-14" a1)
(return)
))
(loader'((fentry m-bar1-f-foo-15 subr0)
(entry m-bar1-f-foo-15 subr0)
(mov '"f-foo-15" a1)
(return)
))
(loader'((fentry m-goo1-m-bar-2f-foo-16 subr0)
(entry m-goo1-m-bar-2f-foo-16 subr0)
(mov 'm-bar-2f-foo-16 a1)
(return)
))
(loader'((fentry m-bar1-f-foo-17 subr0)
(entry m-bar1-f-foo-17 subr0)
(mov '"f-foo-17" a1)
(return)
))
(putprop 's-foo '((() ()) a b) 'defstruct)
(loader'((fentry #:s-foo:make subr0)
(entry #:s-foo:make subr0)
(push (@ 101))
(push nil)
(push nil)
(mov '2 a4)
(jmp vector)
101
(eval ())
(mov 's-foo (cdr a1))
(return)
))
(loader'((fentry #:s-foo:a nsubr)
(entry #:s-foo:a nsubr)
(push a4)
(push (@ 101))
(push '#:s-foo:a)
(push '0)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (progn (putprop '#:s-foo:a '#:s-foo:a 'setf-inverse) '#:s-foo:a)))
(if (featurep 'compiler) (progn (defmacro-open #:s-foo:a (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(loader'((fentry #:s-foo:b nsubr)
(entry #:s-foo:b nsubr)
(push a4)
(push (@ 101))
(push '#:s-foo:b)
(push '1)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (progn (putprop '#:s-foo:b '#:s-foo:b 'setf-inverse) '#:s-foo:b)))
(if (featurep 'compiler) (progn (defmacro-open #:s-foo:b (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(putprop '#:tclass:t-foo '((() ()) a b) 'defstruct)
(loader'((fentry #:tclass:t-foo:make subr0)
(entry #:tclass:t-foo:make subr0)
(push (@ 101))
(push nil)
(push nil)
(mov '2 a4)
(jmp vector)
101
(eval ())
(mov '#:tclass:t-foo (cdr a1))
(return)
))
(loader'((fentry #:tclass:t-foo:a nsubr)
(entry #:tclass:t-foo:a nsubr)
(push a4)
(push (@ 101))
(push '#:tclass:t-foo:a)
(push '0)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (progn (putprop '#:tclass:t-foo:a '#:tclass:t-foo:a 'setf-inverse) '#:tclass:t-foo:a)))
(if (featurep 'compiler) (progn (defmacro-open #:tclass:t-foo:a (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(loader'((fentry #:tclass:t-foo:b nsubr)
(entry #:tclass:t-foo:b nsubr)
(push a4)
(push (@ 101))
(push '#:tclass:t-foo:b)
(push '1)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (progn (putprop '#:tclass:t-foo:b '#:tclass:t-foo:b 'setf-inverse) '#:tclass:t-foo:b)))
(if (featurep 'compiler) (progn (defmacro-open #:tclass:t-foo:b (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(put-abbrev 't-foo '#:tclass:t-foo)
'#:tclass:t-foo
(put-abbrev 'a-s-foo3 '#:bar:a-bar3:s-foo3)
(putprop '#:bar:a-bar3:s-foo3 '((()) z) 'defstruct)
(loader'((fentry #:bar:a-bar3:s-foo3:make subr0)
(entry #:bar:a-bar3:s-foo3:make subr0)
(push (@ 101))
(push nil)
(mov '1 a4)
(jmp vector)
101
(eval ())
(mov '#:bar:a-bar3:s-foo3 (cdr a1))
(return)
))
(loader'((fentry #:bar:a-bar3:s-foo3:z nsubr)
(entry #:bar:a-bar3:s-foo3:z nsubr)
(push a4)
(push (@ 101))
(push '#:bar:a-bar3:s-foo3:z)
(push '0)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (progn (putprop '#:bar:a-bar3:s-foo3:z '#:bar:a-bar3:s-foo3:z 'setf-inverse) '#:bar:a-bar3:s-foo3:z)))
(if (featurep 'compiler) (progn (defmacro-open #:bar:a-bar3:s-foo3:z (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(loader'((entry f-foo20 subr1)
(return)
))
(loader'((entry f-foo21 subr1)
(return)
))
(loader'((fentry f-foo23 subr1)
(entry f-foo23 subr1)
(jmp f-foo23)
))
(loader'((fentry f-foo24 subr1)
(entry f-foo24 subr1)
(return)
))
(loader'((entry f-foo25 subr1)
(return)
))
(loader'((fentry f-foo26 subr1)
(entry f-foo26 subr1)
(return)
))
(loader'((fentry f-foo27 subr1)
(entry f-foo27 subr1)
(return)
))
(loader'((fentry f-foo28 subr1)
(entry f-foo28 subr1)
(return)
))
(loader'((entry f-foo29 subr1)
(hpxmov a1 '1 a1)
(return)
))
(loader'((fentry f-foo3 subr1)
(entry f-foo3 subr1)
(call f-foo21)
(bra f-foo20)
))
(loader'((fentry f-foo31 subr1)
(entry f-foo31 subr1)
(call f-too99)
(bra f-foo20)
))
(put-abbrev 'a-foo1 'foo1)
(loader'((fentry #:foo1:f-foo4 subr1)
(entry #:foo1:f-foo4 subr1)
(return)
))
(loader'((fentry #:foo1:f-foo41 subr1)
(entry #:foo1:f-foo41 subr1)
(jmp #:bar:a-bar1:f-bar2)
))
(loader'((fentry #:foo1:f-foo42 subr1)
(entry #:foo1:f-foo42 subr1)
(bra #:bar:a-bar1:asd:f-bar2)
))
(loader'((fentry #:foo1:asd:f-foo43 subr1)
(entry #:foo1:asd:f-foo43 subr1)
(return)
))
(loader'((fentry f-foo6 subr1)
(entry f-foo6 subr1)
(return)
))
(f-foo6 0)
(f-foo6 1)
(f-foo6 2)
(f-foo6 3)
(f-foo6 4)
(loader'((fentry f-foo61 subr1)
(entry f-foo61 subr1)
(push (@ 101))
(push '"       f-foo61 is used inline")
(mov '1 a4)
(jmp print)
101
(eval ())
(return)
))
(f-foo61 0)
(loader'((fentry f-foo71 subr1)
(entry f-foo71 subr1)
(push (@ 101))
(push 'f-foo24)
(push a1)
(mov '2 a4)
(jmp funcall)
101
(eval ())
(return)
))
(loader'((fentry f-foo72 subr1)
(entry f-foo72 subr1)
(push (@ 101))
(push 'f-bar41)
(push a1)
(mov '2 a4)
(jmp funcall)
101
(eval ())
(return)
))
(loader'((fentry f-foo73 subr1)
(entry f-foo73 subr1)
(push a1)
101
(bfcons (& 0) 102)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(call f-foo25)
(bra 101)
102
(mov nil a1)
(adjstk '1)
(return)
))
(loader'((fentry f-foo74 subr1)
(entry f-foo74 subr1)
(push a1)
101
(bfcons (& 0) 102)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(jcall f-bar42)
(bra 101)
102
(mov nil a1)
(adjstk '1)
(return)
))
(loader'((fentry f-foo75 subr0)
(entry f-foo75 subr0)
(mov 'f-foo26 a1)
(jmp mapoblist)
))
(loader'((fentry f-foo76 subr0)
(entry f-foo76 subr0)
(mov 'f-bar43 a1)
(jmp mapoblist)
))
(synonym 'f-foo81 'f-foo1)
(synonym 'f-foo82 'f-foo27)
(synonym 'f-foo83 'f-bar5)
(synonym 'f-foo84 'car)
(loader'((fentry f-foo91 subr1)
(entry f-foo91 subr1)
(bra f-foo29)
))
(loader'((fentry f-foo91 subr1)
(entry f-foo91 subr1)
(bra f-foo29)
))
(loader'((fentry f-fooa1 subr1)
(entry f-fooa1 subr1)
(push nil)
(mov '(x . x) a2)
(jcall cons)
(mov (& 0) a1)
(adjstk '1)
(bra f-foo21)
))
(defsharp @ () ((lambda (x) (ncons (list 'cons x x))) (read)))
(loader'((fentry f-fooa2 subr1)
(entry f-fooa2 subr1)
(mov a1 a2)
(jcall cons)
(bra f-foo21)
))
(setq #:system:defstruct-all-access-flag t)
(putprop '#:s-fee:s-fooa3 '((()) c) 'defstruct)
(loader'((fentry #:s-fee:s-fooa3:make subr0)
(entry #:s-fee:s-fooa3:make subr0)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(mov '3 a4)
(jmp vector)
101
(eval ())
(mov '#:s-fee:s-fooa3 (cdr a1))
(return)
))
(loader'((fentry #:s-fee:s-fooa3:a nsubr)
(entry #:s-fee:s-fooa3:a nsubr)
(push a4)
(push (@ 101))
(push '#:s-fee:s-fooa3:a)
(push '0)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa3:a #:s-fee:s-fooa3:a)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa3:a (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(loader'((fentry #:s-fee:s-fooa3:b nsubr)
(entry #:s-fee:s-fooa3:b nsubr)
(push a4)
(push (@ 101))
(push '#:s-fee:s-fooa3:b)
(push '1)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa3:b #:s-fee:s-fooa3:b)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa3:b (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(loader'((fentry #:s-fee:s-fooa3:c nsubr)
(entry #:s-fee:s-fooa3:c nsubr)
(push a4)
(push (@ 101))
(push '#:s-fee:s-fooa3:c)
(push '2)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa3:c #:s-fee:s-fooa3:c)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa3:c (struct . valeur) (ifn valeur (list 'vref struct 2) (list 'vset struct 2 (car valeur))))))
(setq #:system:defstruct-all-access-flag ())
(putprop '#:s-fee:s-fooa4 '((()) c) 'defstruct)
(loader'((fentry #:s-fee:s-fooa4:make subr0)
(entry #:s-fee:s-fooa4:make subr0)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(mov '3 a4)
(jmp vector)
101
(eval ())
(mov '#:s-fee:s-fooa4 (cdr a1))
(return)
))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa4:a #:s-fee:s-fooa4:a)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa4:a (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa4:b #:s-fee:s-fooa4:b)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa4:b (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(loader'((fentry #:s-fee:s-fooa4:c nsubr)
(entry #:s-fee:s-fooa4:c nsubr)
(push a4)
(push (@ 101))
(push '#:s-fee:s-fooa4:c)
(push '2)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:s-fee:s-fooa4:c #:s-fee:s-fooa4:c)))
(if (featurep 'compiler) (progn (defmacro-open #:s-fee:s-fooa4:c (struct . valeur) (ifn valeur (list 'vref struct 2) (list 'vset struct 2 (car valeur))))))
(loader '((end)))

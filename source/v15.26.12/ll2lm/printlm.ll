
(setq #:sys-package:colon '{diagnostic})

#|===========================================================================
   Mise a` jour du fichier descripteur du module dont le nom est dans la
   variable globale :mod-path sous forme de chaine.
---------------------------------------------------------------------------|#

(defun :update-desc (file diag)
  (if (or ({diagnostic}:import-rewrite-p diag)
	  ({diagnostic}:export-rewrite-p diag)
	  ({diagnostic}:cpenv-rewrite-p diag))
      (let ((def (readdefmodule file))
	    (#:system:print-with-abbrev-flag ())
	    ndef
	    )
	(setq ndef (:set-def def diag))
	(unless #:crunch:keep-old
		(#:crunch:save-file file)
		(#:crunch:advise UPDATEMODULE file)
		(:printdefmodule ndef file)
		))
    (#:crunch:advise NONEEDWRITE file)))

;;;
;;; Fonction affichant une description de module en accord avec le diagnostic
;;; de l'analyseur.
;;; La description est hautement commente'e.

(defun :set-def (def diag)
  (let (
	(inc (getdefmodule def 'include))
	(imp (getdefmodule def 'import))
	(exp (getdefmodule def 'export))
	(ninc (simplify-list
	       (apply 'append
		      (mapcar 'cdr ({diagnostic}:necessary-include diag)))))
	(ni ({diagnostic}:necessary-imports diag))
	(ei ({diagnostic}:excess-imports diag))
	(lne ({llmodule}:format-export
	      ({diagnostic}:localy-necessary-exports diag)))
	(ene ({llmodule}:format-export
	      ({diagnostic}:extern-necessary-exports diag)))
	(dne ({llmodule}:format-export
	      ({diagnostic}:dynamic-necessary-exports diag)))
	(ee ({llmodule}:format-export ({diagnostic}:excess-exports diag)))
	(if ({llmodule}:format-export ({diagnostic}:internal-functions diag)))
	(cp ({diagnostic}:exported-cpenv diag))
	)
					; include
    (if (or inc ninc)
	(setdefmodule def 'include
		      `(,.(if #:crunch:keep-wrong
			      (union ninc inc)
			    ninc)
			)))
			    
					; import
    (setdefmodule def 'import
		  `(,@(when ni
			    (:prin-in-lm ";;; Imports which seem necessary"
					 ni))
		    ,@(when ei
			    (if #:crunch:keep-wrong
				(:prin-in-lm ";;; User-imported modules"
					     ei)
			      (:comm-in-lm ";;; Ignoring unneeded imported modules"
					   ei)))
		    ))
    
					; export
    (setdefmodule def 'export
		  `(,.(when lne
			    (:prin-in-lm ";;; Functions unused unless exported"
					 lne))
		    ,.(when ene
			    (:prin-in-lm ";;; Exports required by other modules"
					 ene))
		    ,.(when dne
			    (:prin-in-lm ";;; Exported because dynamically used"
					 dne))
		    ,.(when if
			    (if #:crunch:keep-all-exports
				(:prin-in-lm ";;; Exported because all exports required"
					     if)
			      (if #:crunch:keep-wrong
				  (let* ((exported
					  (intersection if exp))
					 (noexported
					  (set-difference if exported)))
				    (when exported
					  (:prin-in-lm ";;; Internally used but export required by user"
						       exported))
				    (when noexported
					  (:comm-in-lm ";;; Not exported because only internally used"
						       noexported)))
				(:comm-in-lm ";;; Not exported because only internally used"
					     if))))
		    ,.(when ee
			    (if #:crunch:keep-wrong
				(:prin-in-lm  ";;; Not defined but export required by user"
					      ee)
			      (:comm-in-lm ";;; Not exported because not defined"
					   ee)))
		    ))
					; comments
    (setdefmodule def 'comments
		  (if #:crunch:keep-wrong
		      '(";;; This module descriptor was updated by Analyser")
		    '(";;; This module descriptor was generated by Analyser")))

					; cpenv
    (when cp
	  (setdefmodule def 'cpenv cp))
					; complice's fields : remove them
    (let ((cpexport (assq 'cpexport def)))
      (if cpexport (delete cpexport def)))
    (let ((cpimport (assq 'cpimport def)))
      (if cpimport (delete cpimport def)))
    (let ((cpfunctions (assq 'cpfunctions def)))
      (if cpfunctions (delete cpfunctions def)))
    def
    ))

;; to print or with or without comment
(defmacro :prin-in-lm (msg lst)
  `(cons `(analyzer-comment ,,msg) ,lst))

(defmacro :comm-in-lm (msg lst)
  `(list `(analyzer-comment ,,msg ,@,lst)))

;;; idem real PRINTDEFMODULE but don't verify if need rewrite
;;; and new comment's mechanism
(defun :printdefmodule (defmod mod)
  (ifn mod
       (error 'printdefmodule '#:module:ERRNMD mod)
     (let ((out (catcherror () (openo mod))))
       (ifn out
	    (error 'printdefmodule '#:module:ERRFPR out)
	 (protect
	  (with ((outchan (setq out (car out)))
		 (printlength 0)
		 (printlevel 0)
		 (printline 0)
		 )
		(when (getdefmodule defmod 'comments)
		      (with ((rmargin (add1 (slen (outbuf)))))
			    (let ((#:system:print-for-read ()))
			      (mapc (lambda (x) (print "; " x))
				    (getdefmodule defmod
						  'comments)))
			    ))
		(:print-rest-of-keys defmod ())
		)
	  (close out))
	  )))
  mod)

(defun :print-rest-of-keys (defmod except)
  (let ((#:system:print-for-read t))
    (mapc (lambda (slot)
	    (let ((key (car slot))
		  (value (cdr slot)))
	      (unless (or (memq key '(#:module:header #:module:deadheader comments))
			  (memq key except))
		      (terpri)
		      (cond ((consp value) ; affiche sur plusieurs lignes.
			     (prin key)
			     (princn #/ )
			     (princn #/()
			     (terpri)
			     (cond
			      ; encore + de lignes
			      ((eq key 'cpenv)
				 (mapc (lambda(l)
					 (if (atom l) (print l)
					   (princn #/()
					   (mapc 'print l)
					   (princn #/))))
				       value))
			      ; attention aux commentaires
			      ((memq key '(import export))
			       (mapc (lambda(v)
				       (if (and (consp v)
						(eq (car v) 'analyzer-comment))
					   (let ((#:system:print-for-read ()))
					      (with ((rmargin
						      (add1(slen (outbuf)))))
						    (terpri)
						    (mapc (lambda(vv)
							    (print "; " vv))
							  (cdr v))
						    ))
					 (print v)))
				     value))
			      (t
			       (mapc 'print value)))
			     (princn #/))
			     (terpri))
			    (t
			     (prin key)(princn #/ )(prin value)
			     (terpri))))))
	  defmod)))

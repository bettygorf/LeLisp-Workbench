(loader '((title |defrtprj.lo|)))
(defvar rtdir (if (and (boundp 'rtdir) rtdir) rtdir (or (getenv "RTDIR") (combine-pathnames (pathname #:system:directory) #:pathname:#[ () () (#:pathname:current "modana") () () () ]))))
(print "rtdir is " rtdir)
(defvar crunch-dir rtdir)
(setq #:system:path (delete rtdir #:system:path))
(if rtdir (progn (newr #:system:path rtdir)))
(defvar rt-lelisp-directory (if (boundp 'rt-lelisp-directory) rt-lelisp-directory #:system:directory))
(setq #:sys-package:colon 'rtproject)
(put-abbrev 'rtproject 'rtproject)
(putprop 'rtproject '((() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) name required-projects root-directory directories system-directory crunch-directory modules-directories ll-object-directory ll-object-directories ll-module-directory ll-module-directories module-extension ref-file project-file make-file init-makefile activate-function initialize-function modules-lists modules exclude-modules required-modules extensions-list modules-files builtp loadedp meta-ref-file meta-module complice-flags complice-options analyzer-options rt-gell-p) 'defstruct)
(loader'((fentry #:rtproject:make subr0)
(entry #:rtproject:make subr0)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(push nil)
(mov '32 a4)
(jmp vector)
101
(eval ())
(mov 'rtproject (cdr a1))
(return)
))
(loader'((fentry #:rtproject:name nsubr)
(entry #:rtproject:name nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:name)
(push '0)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:name #:rtproject:name)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:name (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(loader'((fentry #:rtproject:required-projects nsubr)
(entry #:rtproject:required-projects nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:required-projects)
(push '1)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:required-projects #:rtproject:required-projects)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:required-projects (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(loader'((fentry #:rtproject:root-directory nsubr)
(entry #:rtproject:root-directory nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:root-directory)
(push '2)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:root-directory #:rtproject:root-directory)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:root-directory (struct . valeur) (ifn valeur (list 'vref struct 2) (list 'vset struct 2 (car valeur))))))
(loader'((fentry #:rtproject:directories nsubr)
(entry #:rtproject:directories nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:directories)
(push '3)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:directories #:rtproject:directories)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:directories (struct . valeur) (ifn valeur (list 'vref struct 3) (list 'vset struct 3 (car valeur))))))
(loader'((fentry #:rtproject:system-directory nsubr)
(entry #:rtproject:system-directory nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:system-directory)
(push '4)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:system-directory #:rtproject:system-directory)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:system-directory (struct . valeur) (ifn valeur (list 'vref struct 4) (list 'vset struct 4 (car valeur))))))
(loader'((fentry #:rtproject:crunch-directory nsubr)
(entry #:rtproject:crunch-directory nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:crunch-directory)
(push '5)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:crunch-directory #:rtproject:crunch-directory)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:crunch-directory (struct . valeur) (ifn valeur (list 'vref struct 5) (list 'vset struct 5 (car valeur))))))
(loader'((fentry #:rtproject:modules-directories nsubr)
(entry #:rtproject:modules-directories nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:modules-directories)
(push '6)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:modules-directories #:rtproject:modules-directories)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:modules-directories (struct . valeur) (ifn valeur (list 'vref struct 6) (list 'vset struct 6 (car valeur))))))
(loader'((fentry #:rtproject:ll-object-directory nsubr)
(entry #:rtproject:ll-object-directory nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:ll-object-directory)
(push '7)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:ll-object-directory #:rtproject:ll-object-directory)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:ll-object-directory (struct . valeur) (ifn valeur (list 'vref struct 7) (list 'vset struct 7 (car valeur))))))
(loader'((fentry #:rtproject:ll-object-directories nsubr)
(entry #:rtproject:ll-object-directories nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:ll-object-directories)
(push '8)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:ll-object-directories #:rtproject:ll-object-directories)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:ll-object-directories (struct . valeur) (ifn valeur (list 'vref struct 8) (list 'vset struct 8 (car valeur))))))
(loader'((fentry #:rtproject:ll-module-directory nsubr)
(entry #:rtproject:ll-module-directory nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:ll-module-directory)
(push '9)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:ll-module-directory #:rtproject:ll-module-directory)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:ll-module-directory (struct . valeur) (ifn valeur (list 'vref struct 9) (list 'vset struct 9 (car valeur))))))
(loader'((fentry #:rtproject:ll-module-directories nsubr)
(entry #:rtproject:ll-module-directories nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:ll-module-directories)
(push '10)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:ll-module-directories #:rtproject:ll-module-directories)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:ll-module-directories (struct . valeur) (ifn valeur (list 'vref struct 10) (list 'vset struct 10 (car valeur))))))
(loader'((fentry #:rtproject:module-extension nsubr)
(entry #:rtproject:module-extension nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:module-extension)
(push '11)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:module-extension #:rtproject:module-extension)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:module-extension (struct . valeur) (ifn valeur (list 'vref struct 11) (list 'vset struct 11 (car valeur))))))
(loader'((fentry #:rtproject:ref-file nsubr)
(entry #:rtproject:ref-file nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:ref-file)
(push '12)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:ref-file #:rtproject:ref-file)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:ref-file (struct . valeur) (ifn valeur (list 'vref struct 12) (list 'vset struct 12 (car valeur))))))
(loader'((fentry #:rtproject:project-file nsubr)
(entry #:rtproject:project-file nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:project-file)
(push '13)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:project-file #:rtproject:project-file)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:project-file (struct . valeur) (ifn valeur (list 'vref struct 13) (list 'vset struct 13 (car valeur))))))
(loader'((fentry #:rtproject:make-file nsubr)
(entry #:rtproject:make-file nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:make-file)
(push '14)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:make-file #:rtproject:make-file)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:make-file (struct . valeur) (ifn valeur (list 'vref struct 14) (list 'vset struct 14 (car valeur))))))
(loader'((fentry #:rtproject:init-makefile nsubr)
(entry #:rtproject:init-makefile nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:init-makefile)
(push '15)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:init-makefile #:rtproject:init-makefile)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:init-makefile (struct . valeur) (ifn valeur (list 'vref struct 15) (list 'vset struct 15 (car valeur))))))
(loader'((fentry #:rtproject:activate-function nsubr)
(entry #:rtproject:activate-function nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:activate-function)
(push '16)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:activate-function #:rtproject:activate-function)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:activate-function (struct . valeur) (ifn valeur (list 'vref struct 16) (list 'vset struct 16 (car valeur))))))
(loader'((fentry #:rtproject:initialize-function nsubr)
(entry #:rtproject:initialize-function nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:initialize-function)
(push '17)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:initialize-function #:rtproject:initialize-function)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:initialize-function (struct . valeur) (ifn valeur (list 'vref struct 17) (list 'vset struct 17 (car valeur))))))
(loader'((fentry #:rtproject:modules-lists nsubr)
(entry #:rtproject:modules-lists nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:modules-lists)
(push '18)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:modules-lists #:rtproject:modules-lists)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:modules-lists (struct . valeur) (ifn valeur (list 'vref struct 18) (list 'vset struct 18 (car valeur))))))
(loader'((fentry #:rtproject:modules nsubr)
(entry #:rtproject:modules nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:modules)
(push '19)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:modules #:rtproject:modules)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:modules (struct . valeur) (ifn valeur (list 'vref struct 19) (list 'vset struct 19 (car valeur))))))
(loader'((fentry #:rtproject:exclude-modules nsubr)
(entry #:rtproject:exclude-modules nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:exclude-modules)
(push '20)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:exclude-modules #:rtproject:exclude-modules)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:exclude-modules (struct . valeur) (ifn valeur (list 'vref struct 20) (list 'vset struct 20 (car valeur))))))
(loader'((fentry #:rtproject:required-modules nsubr)
(entry #:rtproject:required-modules nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:required-modules)
(push '21)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:required-modules #:rtproject:required-modules)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:required-modules (struct . valeur) (ifn valeur (list 'vref struct 21) (list 'vset struct 21 (car valeur))))))
(loader'((fentry #:rtproject:extensions-list nsubr)
(entry #:rtproject:extensions-list nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:extensions-list)
(push '22)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:extensions-list #:rtproject:extensions-list)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:extensions-list (struct . valeur) (ifn valeur (list 'vref struct 22) (list 'vset struct 22 (car valeur))))))
(loader'((fentry #:rtproject:modules-files nsubr)
(entry #:rtproject:modules-files nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:modules-files)
(push '23)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:modules-files #:rtproject:modules-files)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:modules-files (struct . valeur) (ifn valeur (list 'vref struct 23) (list 'vset struct 23 (car valeur))))))
(loader'((fentry #:rtproject:builtp nsubr)
(entry #:rtproject:builtp nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:builtp)
(push '24)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:builtp #:rtproject:builtp)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:builtp (struct . valeur) (ifn valeur (list 'vref struct 24) (list 'vset struct 24 (car valeur))))))
(loader'((fentry #:rtproject:loadedp nsubr)
(entry #:rtproject:loadedp nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:loadedp)
(push '25)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:loadedp #:rtproject:loadedp)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:loadedp (struct . valeur) (ifn valeur (list 'vref struct 25) (list 'vset struct 25 (car valeur))))))
(loader'((fentry #:rtproject:meta-ref-file nsubr)
(entry #:rtproject:meta-ref-file nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:meta-ref-file)
(push '26)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:meta-ref-file #:rtproject:meta-ref-file)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:meta-ref-file (struct . valeur) (ifn valeur (list 'vref struct 26) (list 'vset struct 26 (car valeur))))))
(loader'((fentry #:rtproject:meta-module nsubr)
(entry #:rtproject:meta-module nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:meta-module)
(push '27)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:meta-module #:rtproject:meta-module)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:meta-module (struct . valeur) (ifn valeur (list 'vref struct 27) (list 'vset struct 27 (car valeur))))))
(loader'((fentry #:rtproject:complice-flags nsubr)
(entry #:rtproject:complice-flags nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:complice-flags)
(push '28)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:complice-flags #:rtproject:complice-flags)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:complice-flags (struct . valeur) (ifn valeur (list 'vref struct 28) (list 'vset struct 28 (car valeur))))))
(loader'((fentry #:rtproject:complice-options nsubr)
(entry #:rtproject:complice-options nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:complice-options)
(push '29)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:complice-options #:rtproject:complice-options)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:complice-options (struct . valeur) (ifn valeur (list 'vref struct 29) (list 'vset struct 29 (car valeur))))))
(loader'((fentry #:rtproject:analyzer-options nsubr)
(entry #:rtproject:analyzer-options nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:analyzer-options)
(push '30)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:analyzer-options #:rtproject:analyzer-options)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:analyzer-options (struct . valeur) (ifn valeur (list 'vref struct 30) (list 'vset struct 30 (car valeur))))))
(loader'((fentry #:rtproject:rt-gell-p nsubr)
(entry #:rtproject:rt-gell-p nsubr)
(push a4)
(push (@ 101))
(push '#:rtproject:rt-gell-p)
(push '31)
(mov (& 3) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(mov (& 4) a4)
(plus '3 a4)
(xspmov a4 a4)
(push a4)
(push (& 5))
(mov '5 a4)
(jmp #:system:structaccess)
101
(eval ())
(pop a4)
(adjstk a4)
(return)
))
(if (featurep 'setf) (progn (defsetf #:rtproject:rt-gell-p #:rtproject:rt-gell-p)))
(if (featurep 'compiler) (progn (defmacro-open #:rtproject:rt-gell-p (struct . valeur) (ifn valeur (list 'vref struct 31) (list 'vset struct 31 (car valeur))))))
(loader'((entry #:rtproject:make-ref-file subr2)
(push a1)
(mov a2 a1)
(jcall pathname)
(push a1)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(hpxmov (& 5) '0 a1)
(jcall string)
(push a1)
(push '"ref")
(push nil)
(mov '6 a4)
(jmp make-pathname)
101
(eval ())
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp merge-pathnames)
))
(loader'((entry #:rtproject:make-meta-ref-file subr2)
(push a1)
(mov a2 a1)
(jcall pathname)
(push a1)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(push (@ 102))
(push '"m_")
(hpxmov (& 7) '0 a1)
(jcall string)
(push a1)
(mov '2 a4)
(jmp catenate)
102
(eval ())
(jcall string)
(push a1)
(push '"ref")
(push nil)
(mov '6 a4)
(jmp make-pathname)
101
(eval ())
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp merge-pathnames)
))
(loader'((entry #:rtproject:make-make-file subr2)
(push a1)
(mov a2 a1)
(jcall pathname)
(push a1)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(hpxmov (& 5) '0 a1)
(jcall string)
(push a1)
(btnil (cvalq #:system:unixp) 102)
(mov '"mk" a4)
(bra 103)
102
(btnil (cvalq #:system:dosp) 104)
(mov '"mk" a4)
(bra 103)
104
(btnil (cvalq #:system:vmsp) 106)
(mov '"mms" a4)
(bra 103)
106
(mov '"mk" a4)
103
(push a4)
(push nil)
(mov '6 a4)
(jmp make-pathname)
101
(eval ())
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp merge-pathnames)
))
(loader'((entry #:rtproject:make-init-file subr2)
(push a1)
(mov a2 a1)
(jcall pathname)
(push a1)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(hpxmov (& 5) '0 a1)
(jcall string)
(push a1)
(btnil (cvalq #:system:unixp) 102)
(mov '"mki" a4)
(bra 103)
102
(btnil (cvalq #:system:dosp) 104)
(mov '"mki" a4)
(bra 103)
104
(btnil (cvalq #:system:vmsp) 106)
(mov '"mmsi" a4)
(bra 103)
106
(mov '"mki" a4)
103
(push a4)
(push nil)
(mov '6 a4)
(jmp make-pathname)
101
(eval ())
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp merge-pathnames)
))
(loader'((entry #:rtproject:make-project-file subr2)
(push a1)
(mov a2 a1)
(jcall pathname)
(push a1)
(push (@ 101))
(push nil)
(push nil)
(push nil)
(hpxmov (& 5) '0 a1)
(jcall string)
(push a1)
(push '"prj")
(push nil)
(mov '6 a4)
(jmp make-pathname)
101
(eval ())
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp merge-pathnames)
))
'(eval-when (load eval compile) (defstruct rtprojectdata closure modules))
(loader'((fentry define-rt-project dmsubr)
(entry define-rt-project dmsubr)
(mov (cdr a1) a4)
(mov (car a1) a1)
(push a4)
(push (@ 101))
(push 'declare-rt-project)
(push (@ 102))
(push '#:rtproject:defrtproject)
(push '(new 'rtproject))
(push (@ 103))
(push 'quote)
(push a1)
(mov '2 a4)
(jmp list)
103
(eval ())
(push a1)
(push (@ 104))
(push 'quote)
(push (& 8))
(mov '2 a4)
(jmp list)
104
(eval ())
(push a1)
(push '(t))
(mov '5 a4)
(jmp mcons)
102
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
101
(eval ())
(adjstk '1)
(return)
))
(loader'((fentry define-rt-group-project dmsubr)
(entry define-rt-group-project dmsubr)
(mov (cdr a1) a4)
(mov (car a1) a1)
(push a4)
(push (@ 101))
(push 'declare-rt-group-project)
(push (@ 102))
(push '#:rtproject:defrtproject)
(push '(new 'rtproject))
(push (@ 103))
(push 'quote)
(push a1)
(mov '2 a4)
(jmp list)
103
(eval ())
(push a1)
(push (@ 104))
(push 'quote)
(push (& 8))
(mov '2 a4)
(jmp list)
104
(eval ())
(push a1)
(push '(()))
(mov '5 a4)
(jmp mcons)
102
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
101
(eval ())
(adjstk '1)
(return)
))
(loader'((fentry #:rtproject:defrtproject nsubr)
(entry #:rtproject:defrtproject nsubr)
(cnbeq a4 '4 101)
(mov '#:rtproject:defrtproject a1)
(mov '4 a2)
(jmp #:llcp:errwna)
101
(hpmovx (& 2) (& 3) '0)
(btnil (& 0) 102)
(mov 'defstruct a2)
(mov 'rtproject a1)
(jcall getprop)
(mov a1 a4)
(bra 103)
102
(mov '(root-directory crunch-directory required-projects) a4)
103
(push nil)
(push nil)
(push a4)
104
(btnil (& 4) 105)
(mov (& 4) a4)
(mov (cdr a4) (& 4))
(mov (car a4) (& 2))
(mov (& 4) a4)
(mov (cdr a4) (& 4))
(mov (car a4) (& 1))
(push 't)
(push (cvalq #:system:error-flag))
(mov (& 1) (cvalq #:system:error-flag))
(push '1)
(push '(#:system:error-flag))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 108))
(push '#:system:error-tag)
(push dlink)
(push tag)
(stack dlink)
(mov nil a1)
(jcall ncons)
(mov (& 1) dlink)
(adjstk '4)
108
(eval ())
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:error-flag))
(adjstk '8)
(btnil a1 104)
(mov (& 0) a2)
(mov (& 2) a1)
(jcall memq)
(btnil a1 109)
(push (@ 111))
(mov (& 3) a2)
(mov 'rtproject a1)
(jcall symbol)
(push a1)
(push (& 8))
(push (& 4))
(mov '3 a4)
(jmp funcall)
111
(eval ())
(bra 104)
109
(push (@ 112))
(mov '0 a4)
(jmp outchan)
112
(eval ())
(push a1)
(push (@ 113))
(push dlink)
(push prot)
(stack dlink)
(push (@ 115))
(push nil)
(mov '1 a4)
(jmp outchan)
115
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 14) a3)
(mov '"bad key name" a2)
(mov 'rt-project-key a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 114) a3)
113
(push a3)
(push a2)
(push (@ 116))
(push (& 4))
(mov '1 a4)
(jmp outchan)
116
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
114
(eval ())
(adjstk '1)
(bra 104)
105
(adjstk '3)
(mov (& 3) a1)
(jcall #:rtproject:initialise-structure)
(btnil (& 0) 118)
(push (@ 119))
(push (& 4))
(push nil)
(mov '2 a4)
(bra #:rtproject:check-directories)
119
(eval ())
118
(mov (& 3) a1)
(adjstk '4)
(return)
))
(loader'((fentry #:rtproject:initialise-structure subr1)
(entry #:rtproject:initialise-structure subr1)
(push a1)
(hpxmov a1 '2 a4)
(btnil a4 102)
(hpxmov a1 '2 a1)
(jcall directoryp)
(btnil a1 103)
(hpmovx a1 (& 0) '2)
(bra 102)
103
(hpxmov (& 0) '2 a3)
(mov '"must be a directory" a2)
(mov 'define-rt-project a1)
(jcall error)
102
(hpxmov (& 0) '5 a4)
(bfnil a4 105)
(hpxmov (& 0) '2 a4)
(btnil a4 107)
(hpxmov (& 0) '2 a4)
(hpmovx a4 (& 0) '5)
(bra 106)
107
(mov (cvalq rtdir) a1)
(jcall pathname)
(hpmovx a1 (& 0) '5)
(bra 106)
105
(hpxmov (& 0) '2 a4)
(btnil a4 109)
(hpxmov (& 0) '2 a1)
(jcall pathname)
(bra 110)
109
(mov (cvalq rtdir) a1)
(jcall pathname)
110
(push a1)
(hpxmov (& 1) '5 a1)
(jcall pathname)
(mov a1 a2)
(pop a1)
(jcall combine-pathnames)
(hpmovx a1 (& 0) '5)
106
(hpxmov (& 0) '4 a2)
(mov nil a3)
(mov (& 0) a1)
(call #:rtproject:merge-directory-with-root)
(hpmovx a1 (& 0) '4)
(hpxmov (& 0) '12 a4)
(bfnil a4 112)
(hpxmov (& 0) '5 a2)
(mov (& 0) a1)
(call #:rtproject:make-ref-file)
(hpmovx a1 (& 0) '12)
112
(hpxmov (& 0) '26 a4)
(bfnil a4 114)
(hpxmov (& 0) '5 a2)
(mov (& 0) a1)
(call #:rtproject:make-meta-ref-file)
(hpmovx a1 (& 0) '26)
114
(hpxmov (& 0) '14 a4)
(bfnil a4 116)
(hpxmov (& 0) '4 a2)
(mov (& 0) a1)
(call #:rtproject:make-make-file)
(hpmovx a1 (& 0) '14)
116
(hpxmov (& 0) '15 a4)
(bfnil a4 118)
(hpxmov (& 0) '4 a2)
(mov (& 0) a1)
(call #:rtproject:make-init-file)
(hpmovx a1 (& 0) '15)
118
(hpxmov (& 0) '13 a4)
(bfnil a4 120)
(hpxmov (& 0) '4 a2)
(mov (& 0) a1)
(call #:rtproject:make-project-file)
(hpmovx a1 (& 0) '13)
120
(hpxmov (& 0) '9 a4)
(bfnil a4 121)
(hpxmov (& 0) '10 a4)
(mov (car a4) a4)
(bfnil a4 121)
(hpxmov (& 0) '7 a4)
(bfnil a4 121)
(hpxmov (& 0) '8 a4)
(mov (car a4) a4)
121
(btnil a4 122)
(mov nil a3)
(mov a4 a2)
(mov (& 0) a1)
(call #:rtproject:merge-directory-with-root)
(mov a1 a4)
(bra 123)
122
(mov nil a4)
123
(hpmovx a4 (& 0) '9)
(hpxmov (& 0) '7 a4)
(bfnil a4 124)
(hpxmov (& 0) '8 a4)
(mov (car a4) a4)
(bfnil a4 124)
(hpxmov (& 0) '9 a4)
(bfnil a4 124)
(hpxmov (& 0) '10 a4)
(mov (car a4) a4)
124
(btnil a4 125)
(mov nil a3)
(mov a4 a2)
(mov (& 0) a1)
(call #:rtproject:merge-directory-with-root)
(mov a1 a4)
(bra 126)
125
(mov nil a4)
126
(hpmovx a4 (& 0) '7)
(hpxmov (& 0) '10 a4)
(btnil a4 129)
(hpxmov (& 0) '10 a1)
(hpxmov (& 0) '9 a2)
(mov (car a1) a1)
(jcall equal)
(bfnil a1 128)
129
(hpxmov (& 0) '9 a4)
(btnil a4 130)
(hpxmov (& 0) '9 a1)
(jcall ncons)
(mov a1 a4)
(bra 131)
130
(mov nil a4)
131
(hpmovx a4 (& 0) '10)
128
(hpxmov (& 0) '8 a4)
(btnil a4 134)
(hpxmov (& 0) '8 a1)
(hpxmov (& 0) '7 a2)
(mov (car a1) a1)
(jcall equal)
(bfnil a1 133)
134
(hpxmov (& 0) '7 a4)
(btnil a4 135)
(hpxmov (& 0) '7 a1)
(jcall ncons)
(mov a1 a4)
(bra 136)
135
(mov nil a4)
136
(hpmovx a4 (& 0) '8)
133
(hpxmov (& 0) '3 a2)
(mov nil a3)
(mov (& 0) a1)
(call #:rtproject:merge-directories-with-root)
(hpmovx a1 (& 0) '3)
(hpxmov (& 0) '28 a4)
(btnil a4 138)
(hpxmov (& 0) '29 a2)
(mov '"all" a1)
(jcall cassoc)
(btnil a1 139)
(push (@ 141))
(hpxmov (& 1) '29 a2)
(mov '"all" a1)
(jcall cassoc)
(push a1)
(hpxmov (& 2) '28 a4)
(push a4)
(mov '2 a4)
(jmp nconc)
141
(eval ())
(bra 138)
139
(hpxmov (& 0) '28 a2)
(mov '"all" a1)
(jcall cons)
(hpxmov (& 0) '29 a2)
(jcall cons)
(hpmovx a1 (& 0) '29)
138
(mov (& 0) a1)
(adjstk '1)
(return)
))
(loader'((entry #:rtproject:merge-directories-with-root subr3)
(push a3)
(push a1)
(push a2)
(push nil)
101
(bfcons (& 1) 102)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(mov (& 4) a3)
(mov (& 0) a2)
(mov (& 3) a1)
(call #:rtproject:merge-directory-with-root)
(adjstk '1)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 101)
102
(mov (& 0) a1)
(adjstk '4)
(jmp nreverse)
))
(loader'((entry #:rtproject:merge-directory-with-root subr3)
(push a2)
(bfnil a2 102)
(mov '#:pathname:#[ () () (#:pathname:current) () () () ] (& 0))
102
(cabeq (& 0) '"" 105)
(cabne (& 0) '#:pathname:current 103)
105
(mov '"" a1)
(adjstk '1)
(return)
103
(hpxmov a1 '2 a4)
(btnil a4 106)
(btnil a3 108)
(hpxmov a1 '2 a1)
(jcall pathname)
(push a1)
(push (@ 110))
(jcall system)
(push a1)
(push '"/")
(mov '2 a4)
(jmp catenate)
110
(eval ())
(jcall pathname)
(mov a1 a2)
(pop a1)
(jcall combine-pathnames)
(bra 109)
108
(hpxmov a1 '2 a1)
(jcall pathname)
109
(push a1)
(mov (& 1) a1)
(jcall pathname)
(mov a1 a2)
(pop a1)
(adjstk '1)
(jmp combine-pathnames)
106
(mov (& 0) a1)
(adjstk '1)
(return)
))
(loader'((fentry #:rtproject:prin subr1)
(entry #:rtproject:prin subr1)
(push a1)
(push (@ 101))
(push '"#<rtproject ")
(hpxmov a1 '0 a4)
(push a4)
(mov '2 a4)
(jmp prin)
101
(eval ())
(hpxmov (& 0) '25 a4)
(btnil a4 102)
(push (@ 104))
(push '",loaded")
(mov '1 a4)
(jmp prin)
104
(eval ())
(bra 103)
102
(push (@ 105))
(push '",notloaded")
(mov '1 a4)
(jmp prin)
105
(eval ())
103
(push (@ 106))
(push '">")
(mov '1 a4)
(jmp prin)
106
(eval ())
(mov (& 0) a1)
(adjstk '1)
(return)
))
'(defun #:rtproject:prin (p) (let ((f (cdr (getprop 'rtproject 'defstruct)))) (mapc (lambda (x) (print x " : " (funcall (getfn 'rtproject x) p))) f)))
(loader'((fentry #:rtproject:pretty subr1)
(entry #:rtproject:pretty subr1)
(push a1)
(push (@ 101))
(mov '0 a4)
(jmp printlength)
101
(eval ())
(push a1)
(push (@ 102))
(mov '0 a4)
(jmp printlevel)
102
(eval ())
(push a1)
(push (@ 103))
(mov '0 a4)
(jmp printline)
103
(eval ())
(push a1)
(push (@ 104))
(push dlink)
(push prot)
(stack dlink)
(push (@ 106))
(push '1000)
(mov '1 a4)
(jmp printlength)
106
(eval ())
(push (@ 107))
(push '1000)
(mov '1 a4)
(jmp printlevel)
107
(eval ())
(push (@ 108))
(push '1000)
(mov '1 a4)
(jmp printline)
108
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 109))
(push '"Project name      : ")
(hpxmov (& 16) '0 a4)
(push a4)
(mov '2 a4)
(jmp print)
109
(eval ())
(push (@ 110))
(push '"Root directory    : ")
(hpxmov (& 16) '2 a4)
(push a4)
(mov '2 a4)
(jmp print)
110
(eval ())
(push (@ 111))
(push '"References file   : ")
(hpxmov (& 16) '12 a4)
(push a4)
(mov '2 a4)
(jmp print)
111
(eval ())
(push (@ 112))
(push '"Makefile          : ")
(hpxmov (& 16) '14 a4)
(push a4)
(mov '2 a4)
(jmp print)
112
(eval ())
(push (@ 113))
(push '"Src directories   : ")
(mov '1 a4)
(jmp prin)
113
(eval ())
(push (@ 114))
(push '#:rtproject:prinf)
(hpxmov (& 16) '3 a4)
(push a4)
(push nil)
115
(bfcons (& 1) 116)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(mov (car a1) a1)
(jcall namestring)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 115)
116
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(mov '2 a4)
(jmp funcall)
114
(eval ())
(push (@ 117))
(mov '0 a4)
(jmp terpri)
117
(eval ())
(push (@ 118))
(push '"Modules lists     : ")
(hpxmov (& 16) '18 a4)
(push a4)
(mov '2 a4)
(jmp print)
118
(eval ())
(push (@ 119))
(push '"Modules           : ")
(hpxmov (& 16) '19 a4)
(push a4)
(mov '2 a4)
(jmp print)
119
(eval ())
(push (@ 120))
(push '"Modules required  : ")
(hpxmov (& 16) '21 a4)
(push a4)
(mov '2 a4)
(jmp print)
120
(eval ())
(push (@ 121))
(push '"Exclude modules   : ")
(hpxmov (& 16) '20 a4)
(push a4)
(mov '2 a4)
(jmp print)
121
(eval ())
(hpxmov (& 14) '1 a4)
(btnil a4 123)
(push (@ 124))
(push '"Required projects :    ")
(mov '1 a4)
(jmp prin)
124
(eval ())
(hpxmov (& 14) '1 a1)
(jcall pprint)
123
(push (@ 125))
(mov '0 a4)
(jmp print)
125
(eval ())
(push (@ 126))
(push '"[ANALYZER] Crunch directory   : ")
(hpxmov (& 16) '5 a4)
(push a4)
(mov '2 a4)
(jmp print)
126
(eval ())
(push (@ 127))
(push '"[ANALYZER] modules directory: ")
(mov (& 16) a1)
(jcall get-main-ll-module-directory)
(push a1)
(mov '2 a4)
(jmp print)
127
(eval ())
(push (@ 128))
(push '"[ANALYZER] ANALYSEOPTIONS     : ")
(mov '1 a4)
(jmp print)
128
(eval ())
(hpxmov (& 14) '30 a4)
(push a4)
129
(bfcons (& 0) 130)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(push (@ 131))
(push '"   for module ~A : ~A")
(mov (& 2) a4)
(push (car a4))
(push (cdr a4))
(mov '3 a4)
(jmp prinf)
131
(eval ())
(push (@ 132))
(mov '0 a4)
(jmp terpri)
132
(eval ())
(adjstk '1)
(bra 129)
130
(adjstk '1)
(push (@ 133))
(mov '0 a4)
(jmp print)
133
(eval ())
(push (@ 134))
(push '"[COMPLICE] objects directory : ")
(mov (& 16) a1)
(jcall get-main-ll-object-directory)
(push a1)
(mov '2 a4)
(jmp print)
134
(eval ())
(push (@ 135))
(push '"[COMPLICE] COMPLICEFLAGS      : ")
(mov '1 a4)
(jmp print)
135
(eval ())
(hpxmov (& 14) '29 a4)
(push a4)
136
(bfcons (& 0) 137)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(push (@ 138))
(push '"   for module ~A : ~A")
(mov (& 2) a4)
(push (car a4))
(push (cdr a4))
(mov '3 a4)
(jmp prinf)
138
(eval ())
(push (@ 139))
(mov '0 a4)
(jmp terpri)
139
(eval ())
(adjstk '1)
(bra 136)
137
(mov nil a1)
(adjstk '1)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 105) a3)
104
(push a3)
(push a2)
(push (@ 140))
(push (& 4))
(mov '1 a4)
(jmp printline)
140
(eval ())
(push (@ 141))
(push (& 5))
(mov '1 a4)
(jmp printlevel)
141
(eval ())
(push (@ 142))
(push (& 6))
(mov '1 a4)
(jmp printlength)
142
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
105
(eval ())
(adjstk '4)
(return)
))
'(defun #:rtproject:build-references (project) (unless (#:rtproject:builtp project) (#:rtproject:check-directories project t) (with ((current-directory (#:rtproject:crunch-directory project))) (let ((#:sys-package:itsoft (cons 'rtproject #:sys-package:itsoft))) (with ((all-modules-lists (#:rtproject:modules-lists project)) (exclude-modules (#:rtproject:exclude-modules project)) (all-modules-if-fail (if (#:rtproject:modules-lists project) () t))) (let ((#:system:path (cons "" (#:rtproject:directories project)))) (dirs-to-list () (#:rtproject:modules project)) (list-to-ref))))) (#:rtproject:builtp project t) 'build-references))
(loader'((entry #:rtproject:load nsubr)
(diff '2 a4)
(jcall #:llcp:nlist)
(push a1)
(mov 'meta a2)
(mov (car a1) a1)
(jcall eq)
(mov a1 (& 0))
(hpxmov (& 2) '25 a4)
(bfnil a4 101)
(hpxmov (& 2) '5 a1)
(mov nil a2)
(call #:rtproject:check-directory)
(push (@ 105))
(mov '0 a4)
(jmp current-mr)
105
(eval ())
(bfnil a1 104)
(push (@ 106))
(push (@ 107))
(mov '0 a4)
(jmp standardmodulereferences)
107
(eval ())
(push a1)
(mov '1 a4)
(jmp current-mr)
106
(eval ())
104
(bfnil (& 1) 110)
(mov (cvalq #:crunch:current-project) a2)
(mov (& 2) a1)
(jcall equal)
(btnil a1 109)
110
(push (@ 111))
(mov '0 a4)
(jmp current-mr)
111
(eval ())
(push a1)
(btnil (& 1) 114)
(hpxmov (& 3) '26 a1)
(bra 115)
114
(hpxmov (& 3) '12 a1)
115
(jcall probefile)
(btnil a1 112)
(push (@ 116))
(mov '0 a4)
(jmp standardmodulereferences)
116
(eval ())
(btnil (& 1) 117)
(hpxmov (& 3) '26 a2)
(bra 118)
117
(hpxmov (& 3) '12 a2)
118
(jcall #:llmodulereferences:read-from-file)
(push a1)
(hpxmov (& 4) '0 a4)
(cabne (cvalq #:crunch:all-modules) a4 120)
(hpxmov a1 '1 a4)
(push a4)
(push nil)
121
(bfcons (& 1) 122)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(mov (car a1) a1)
(mov (& 0) a2)
(mov (car a1) a1)
(jcall cons)
(mov a1 (& 0))
(bra 121)
122
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(mov a1 (cvalq #:crunch:all-modules))
120
(mov (& 0) a2)
(adjstk '1)
(bra 113)
112
(push (@ 123))
(mov '0 a4)
(jmp standardmodulereferences)
123
(eval ())
(mov a1 a2)
113
(pop a1)
(jcall #:llmodulereferences:merge-modules-references)
109
(push (@ 124))
(mov (cvalq #:system:path) a2)
(mov '"" a1)
(jcall delete)
(push a1)
(push nil)
125
(bfcons (& 1) 126)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(mov (car a1) a1)
(jcall namestring)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 125)
126
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(push (@ 127))
(hpxmov (& 5) '10 a4)
(push a4)
(push nil)
128
(bfcons (& 1) 129)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(mov (car a1) a1)
(jcall namestring)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 128)
129
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(hpxmov (& 6) '3 a4)
(push a4)
(push nil)
130
(bfcons (& 1) 131)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(mov (car a1) a1)
(jcall namestring)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 130)
131
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(push 'equal)
(mov '3 a4)
(jmp union)
127
(eval ())
(push a1)
(push 'equal)
(mov '3 a4)
(jmp union)
124
(eval ())
(mov a1 a2)
(mov '"" a1)
(jcall cons)
(mov a1 (cvalq #:system:path))
(hpxmov (& 2) '17 a4)
(push a4)
(btnil a4 133)
(push (@ 134))
(mov '0 a4)
(jmp current-directory)
134
(eval ())
(push a1)
(push (@ 135))
(push dlink)
(push prot)
(stack dlink)
(push (@ 137))
(hpxmov (& 8) '2 a4)
(bfnil a4 138)
(push (@ 139))
(mov '0 a4)
(jmp current-directory)
139
(eval ())
(mov a1 a4)
138
(push a4)
(mov '1 a4)
(jmp current-directory)
137
(eval ())
(push 't)
(push (cvalq #:system:error-flag))
(mov (& 1) (cvalq #:system:error-flag))
(push '1)
(push '(#:system:error-flag))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 140))
(push '#:system:error-tag)
(push dlink)
(push tag)
(stack dlink)
(push (@ 141))
(push (& 17))
(mov '1 a4)
(jmp funcall)
141
(eval ())
(jcall ncons)
(mov (& 1) dlink)
(adjstk '4)
140
(eval ())
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:error-flag))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 136) a3)
135
(push a3)
(push a2)
(push (@ 142))
(push (& 4))
(mov '1 a4)
(jmp current-directory)
142
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
136
(eval ())
(adjstk '1)
133
(adjstk '1)
(hpmovx 't (& 2) '25)
(mov 't a1)
(adjstk '3)
(return)
101
(mov nil a1)
(adjstk '3)
(return)
))
(loader'((entry #:rtproject:activate subr1)
(hpxmov a1 '16 a4)
(btnil a4 101)
(push (@ 103))
(push a4)
(mov '1 a4)
(jmp funcall)
103
(eval ())
(return)
101
(mov nil a1)
(return)
))
(loader'((entry #:rtproject:transitive-closure subr3)
(call #:rtproject:transitive-closure-1)
(bra #:rtproject:simplify-equal)
))
(loader'((entry #:rtproject:transitive-closure-1 subr3)
(push a3)
(push a2)
(push a1)
(bfnil a3 103)
(hpxmov a1 '31 a4)
(btnil a4 101)
103
(push (@ 104))
(push (@ 105))
(push a2)
(push a1)
(mov '2 a4)
(jmp funcall)
105
(eval ())
(push a1)
(hpxmov (& 2) '1 a4)
(push a4)
(push nil)
106
(bfcons (& 1) 107)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(mov (& 0) a1)
(jcall find-rt-project)
(btnil a1 108)
(mov (& 0) a1)
(jcall find-rt-project)
(mov (& 7) a3)
(mov (& 6) a2)
(call #:rtproject:transitive-closure-1)
(bra 109)
108
(mov (& 0) a3)
(mov '"undefined project" a2)
(mov 'project-closure a1)
(jcall error)
109
(adjstk '1)
(mov (& 0) a2)
(jcall nreconc)
(mov a1 (& 0))
(bra 106)
107
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(mov '2 a4)
(jmp append)
104
(eval ())
(adjstk '3)
(return)
101
(hpxmov a1 '1 a4)
(push a4)
(push nil)
110
(bfcons (& 1) 111)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(mov (& 0) a1)
(jcall find-rt-project)
(btnil a1 112)
(mov (& 0) a1)
(jcall find-rt-project)
(mov (& 5) a3)
(mov (& 4) a2)
(call #:rtproject:transitive-closure-1)
(bra 113)
112
(mov (& 0) a3)
(mov '"undefined project" a2)
(mov 'project-closure a1)
(jcall error)
113
(adjstk '1)
(mov (& 0) a2)
(jcall nreconc)
(mov a1 (& 0))
(bra 110)
111
(mov (& 0) a1)
(adjstk '5)
(jmp nreverse)
))
'(defun #:rtproject:transitive-closure-but (project func dont-check) (#:rtproject:simplify-equal (#:rtproject:transitive-closure-but-1 project func dont-check)))
'(defun #:rtproject:transitive-closure-but-1 (project func dont-check) (if (or dont-check (not (#:rtproject:rt-gell-p project))) (append (funcall func project) (mapcan (lambda (x) (if (find-rt-project x) (#:rtproject:transitive-closure-but-1 (find-rt-project x) func dont-check) (error 'project-closure "undefined project" x))) (#:rtproject:required-projects project))) (mapcan (lambda (x) (if (find-rt-project x) (#:rtproject:transitive-closure-but-1 (find-rt-project x) func dont-check) (error 'project-closure "undefined project" x))) (#:rtproject:required-projects project))))
(defvar #:rtproject:all-rt-projects (if (boundp '#:rtproject:all-rt-projects) #:rtproject:all-rt-projects))
(defvar #:rtproject:all-rt-group-projects (if (boundp '#:rtproject:all-rt-group-projects) #:rtproject:all-rt-group-projects))
(loader'((fentry list-rt-directories subr1)
(entry list-rt-directories subr1)
(push a1)
(push (@ 101))
(push a1)
(mov '(#:rtproject:directories) a1)
(jcall function)
(mov 't a3)
(mov a1 a2)
(pop a1)
(call #:rtproject:transitive-closure)
(push a1)
(mov '(#:rtproject:ll-object-directories) a1)
(jcall function)
(mov 't a3)
(mov a1 a2)
(mov (& 2) a1)
(call #:rtproject:transitive-closure)
(push a1)
(push (@ 102))
(mov (& 4) a1)
(jcall get-system-directory)
(push a1)
(mov '1 a4)
(jmp list)
102
(eval ())
(push a1)
(mov '3 a4)
(jmp append)
101
(eval ())
(adjstk '1)
(bra #:rtproject:simplify-equal)
))
'(defun list-rt-modules-to-exclude (project) (assert-value project rtproject 'list-rt-modules-to-exclude) (#:rtproject:simplify-eq (#:rtproject:transitive-closure-but project (function (lambda (p) (ifn (#:rtproject:rt-gell-p p) (funcall (function #:rtproject:get-all-modules) p)))) t)))
(loader'((fentry list-complice-directories subr1)
(entry list-complice-directories subr1)
(push a1)
(push (@ 101))
(push a1)
(mov '(#:rtproject:ll-module-directories) a1)
(jcall function)
(mov 't a3)
(mov a1 a2)
(pop a1)
(call #:rtproject:transitive-closure)
(push a1)
(mov '(#:rtproject:ll-object-directories) a1)
(jcall function)
(mov 't a3)
(mov a1 a2)
(mov (& 2) a1)
(call #:rtproject:transitive-closure)
(push a1)
(mov '(#:rtproject:directories) a1)
(jcall function)
(mov 't a3)
(mov a1 a2)
(mov (& 3) a1)
(call #:rtproject:transitive-closure)
(push a1)
(mov (& 4) a1)
(jcall get-system-directory)
(jcall ncons)
(push a1)
(mov '4 a4)
(jmp append)
101
(eval ())
(adjstk '1)
(bra #:rtproject:simplify-equal)
))
(loader'((fentry get-main-ll-object-directory subr1)
(entry get-main-ll-object-directory subr1)
(hpxmov a1 '7 a1)
(return)
))
(loader'((fentry get-main-ll-module-directory subr1)
(entry get-main-ll-module-directory subr1)
(hpxmov a1 '9 a1)
(return)
))
(loader'((fentry get-system-directory subr1)
(entry get-system-directory subr1)
(hpxmov a1 '4 a1)
(return)
))
'(defun get-bin-directory (project) (#:rtproject:bin-directory project))
(loader'((fentry list-complice-flags subr1)
(entry list-complice-flags subr1)
(bra 101)
(fentry #:list-complice-flags:g103 subr1)
(entry #:list-complice-flags:g103 subr1)
(hpxmov a1 '28 a1)
(jmp nreverse)
101
(mov 't a3)
(mov '#:list-complice-flags:g103 a2)
(bra #:rtproject:transitive-closure)
))
(loader'((fentry list-analyzer-options subr1)
(entry list-analyzer-options subr1)
(bra 101)
(fentry #:list-analyzer-options:g104 subr1)
(entry #:list-analyzer-options:g104 subr1)
(hpxmov a1 '30 a1)
(jmp nreverse)
101
(mov 't a3)
(mov '#:list-analyzer-options:g104 a2)
(bra #:rtproject:transitive-closure)
))
(loader'((fentry declared-rt-projects subr0)
(entry declared-rt-projects subr0)
(push (@ 101))
(push (cvalq #:rtproject:all-rt-projects))
(push nil)
102
(bfcons (& 1) 103)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(hpxmov (car a1) '0 a1)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 102)
103
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(push (cvalq #:rtproject:all-rt-group-projects))
(push nil)
104
(bfcons (& 1) 105)
(mov (& 1) a1)
(mov (cdr a1) (& 1))
(hpxmov (car a1) '0 a1)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 104)
105
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(push a1)
(mov '2 a4)
(jmp nconc)
101
(eval ())
(return)
))
(loader'((fentry declare-rt-project subr1)
(entry declare-rt-project subr1)
(push a1)
(mov (cvalq #:rtproject:all-rt-projects) a2)
(jcall memq)
(btnil a1 101)
(push (@ 103))
(mov '0 a4)
(jmp outchan)
103
(eval ())
(push a1)
(push (@ 104))
(push dlink)
(push prot)
(stack dlink)
(push (@ 106))
(push nil)
(mov '1 a4)
(jmp outchan)
106
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 12) a3)
(mov '"this project is alrealy defined" a2)
(mov 'declare-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 105) a3)
104
(push a3)
(push a2)
(push (@ 107))
(push (& 4))
(mov '1 a4)
(jmp outchan)
107
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
105
(eval ())
(adjstk '2)
(return)
101
(hpxmov (& 0) '0 a1)
(jcall find-rt-project)
(btnil a1 109)
(push (@ 110))
(mov '0 a4)
(jmp outchan)
110
(eval ())
(push a1)
(push (@ 111))
(push dlink)
(push prot)
(stack dlink)
(push (@ 113))
(push nil)
(mov '1 a4)
(jmp outchan)
113
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(hpxmov (& 12) '0 a3)
(mov '"overwriting former definition of project" a2)
(mov 'declare-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 112) a3)
111
(push a3)
(push a2)
(push (@ 114))
(push (& 4))
(mov '1 a4)
(jmp outchan)
114
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
112
(eval ())
(adjstk '1)
(hpxmov (& 0) '0 a1)
(jcall remove-rt-project)
109
(push (& 0))
(push (@ 115))
(push (cvalq #:rtproject:all-rt-projects))
(mov (& 2) a1)
(jcall ncons)
(push a1)
(mov '2 a4)
(jmp nconc)
115
(eval ())
(adjstk '1)
(mov a1 (cvalq #:rtproject:all-rt-projects))
(mov (& 0) a1)
(adjstk '1)
(return)
))
(loader'((fentry declare-rt-group-project subr1)
(entry declare-rt-group-project subr1)
(push a1)
(jcall declare-rt-project)
(cabne a1 (& 0) 102)
(hpxmov (& 0) '0 a1)
(jcall find-rt-group-project)
(btnil a1 104)
(hpxmov (& 0) '0 a1)
(jcall remove-rt-group-project)
104
(push (& 0))
(push (@ 105))
(push (cvalq #:rtproject:all-rt-group-projects))
(mov (& 2) a1)
(jcall ncons)
(push a1)
(mov '2 a4)
(jmp nconc)
105
(eval ())
(adjstk '1)
(mov a1 (cvalq #:rtproject:all-rt-group-projects))
102
(mov (& 0) a1)
(adjstk '1)
(return)
))
(loader'((fentry find-rt-project subr1)
(entry find-rt-project subr1)
(push a1)
(bfcons a1 102)
(mov (cdr a1) a4)
(mov (car a4) (& 0))
102
(push (@ 103))
(push 'found)
(push dlink)
(push tag)
(stack dlink)
(push (cvalq #:rtproject:all-rt-projects))
104
(bfcons (& 0) 105)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(hpxmov (& 0) '0 a4)
(cabne a4 (& 6) 107)
(mov (& 0) a1)
(mov 'found a2)
(jmp #:llcp:exit)
107
(adjstk '1)
(bra 104)
105
(mov nil a1)
(adjstk '1)
(mov (& 1) dlink)
(adjstk '4)
103
(eval ())
(adjstk '1)
(return)
))
(loader'((fentry find-rt-group-project subr1)
(entry find-rt-group-project subr1)
(push a1)
(bfcons a1 102)
(mov (cdr a1) a4)
(mov (car a4) (& 0))
102
(push (@ 103))
(push 'found)
(push dlink)
(push tag)
(stack dlink)
(push (cvalq #:rtproject:all-rt-group-projects))
104
(bfcons (& 0) 105)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(hpxmov (& 0) '0 a4)
(cabne a4 (& 6) 107)
(mov (& 0) a1)
(mov 'found a2)
(jmp #:llcp:exit)
107
(adjstk '1)
(bra 104)
105
(mov nil a1)
(adjstk '1)
(mov (& 1) dlink)
(adjstk '4)
103
(eval ())
(adjstk '1)
(return)
))
(loader'((fentry remove-rt-project subr1)
(entry remove-rt-project subr1)
(push a1)
(jcall find-rt-project)
(push a1)
(btnil a1 101)
(mov (cvalq #:rtproject:all-rt-projects) a2)
(jcall delq)
(mov a1 (cvalq #:rtproject:all-rt-projects))
(mov (& 0) a1)
(adjstk '2)
(return)
101
(push (@ 103))
(mov '0 a4)
(jmp outchan)
103
(eval ())
(push a1)
(push (@ 104))
(push dlink)
(push prot)
(stack dlink)
(push (@ 106))
(push nil)
(mov '1 a4)
(jmp outchan)
106
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 13) a3)
(mov '"this project is not defined" a2)
(mov 'remove-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 105) a3)
104
(push a3)
(push a2)
(push (@ 107))
(push (& 4))
(mov '1 a4)
(jmp outchan)
107
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
105
(eval ())
(adjstk '3)
(return)
))
(loader'((fentry remove-rt-group-project subr1)
(entry remove-rt-group-project subr1)
(push a1)
(jcall find-rt-group-project)
(push a1)
(btnil a1 101)
(mov (cvalq #:rtproject:all-rt-group-projects) a2)
(jcall delq)
(mov a1 (cvalq #:rtproject:all-rt-group-projects))
(mov (& 0) a1)
(adjstk '2)
(return)
101
(push (@ 103))
(mov '0 a4)
(jmp outchan)
103
(eval ())
(push a1)
(push (@ 104))
(push dlink)
(push prot)
(stack dlink)
(push (@ 106))
(push nil)
(mov '1 a4)
(jmp outchan)
106
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 13) a3)
(mov '"this project is not defined" a2)
(mov 'remove-rt-group-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 105) a3)
104
(push a3)
(push a2)
(push (@ 107))
(push (& 4))
(mov '1 a4)
(jmp outchan)
107
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
105
(eval ())
(adjstk '3)
(return)
))
(loader'((fentry load-rt-project subr2)
(entry load-rt-project subr2)
(push a2)
(push a1)
(jcall find-rt-project)
(push a1)
(btnil a1 101)
(hpxmov a1 '1 a4)
(push a4)
103
(bfcons (& 0) 104)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(mov (& 4) a2)
(mov (& 0) a1)
(jcall load-rt-project)
(adjstk '1)
(bra 103)
104
(adjstk '1)
(push (@ 105))
(push (& 1))
(push (& 4))
(bfcons (& 4) 106)
(mov (& 4) a4)
(mov (car a4) a4)
(bra 107)
106
(mov nil a4)
107
(push a4)
(mov '3 a4)
(bra #:rtproject:load)
105
(eval ())
(mov (& 0) a1)
(adjstk '3)
(return)
101
(push (@ 108))
(mov '0 a4)
(jmp outchan)
108
(eval ())
(push a1)
(push (@ 109))
(push dlink)
(push prot)
(stack dlink)
(push (@ 111))
(push nil)
(mov '1 a4)
(jmp outchan)
111
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 13) a3)
(mov '"this project is not defined" a2)
(mov 'load-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 110) a3)
109
(push a3)
(push a2)
(push (@ 112))
(push (& 4))
(mov '1 a4)
(jmp outchan)
112
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
110
(eval ())
(adjstk '4)
(return)
))
(loader'((fentry reload-rt-project subr2)
(entry reload-rt-project subr2)
(push a2)
(push a1)
(jcall find-rt-project)
(push a1)
(btnil a1 101)
(hpxmov a1 '1 a4)
(push a4)
103
(bfcons (& 0) 104)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(mov (& 4) a2)
(mov (& 0) a1)
(jcall load-rt-project)
(adjstk '1)
(bra 103)
104
(adjstk '1)
(hpmovx nil (& 0) '25)
(push (@ 105))
(push (& 1))
(push (& 4))
(bfcons (& 4) 106)
(mov (& 4) a4)
(mov (car a4) a4)
(bra 107)
106
(mov nil a4)
107
(push a4)
(mov '3 a4)
(bra #:rtproject:load)
105
(eval ())
(adjstk '3)
(return)
101
(push (@ 108))
(mov '0 a4)
(jmp outchan)
108
(eval ())
(push a1)
(push (@ 109))
(push dlink)
(push prot)
(stack dlink)
(push (@ 111))
(push nil)
(mov '1 a4)
(jmp outchan)
111
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 13) a3)
(mov '"this project is not defined" a2)
(mov 'reload-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 110) a3)
109
(push a3)
(push a2)
(push (@ 112))
(push (& 4))
(mov '1 a4)
(jmp outchan)
112
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
110
(eval ())
(adjstk '4)
(return)
))
'(defun build-rt-project (name . force-rebuild) (assert-value name non-null-symbol 'build-rt-project) (let ((project (find-rt-project name))) (if project (progn (if (car force-rebuild) (#:rtproject:builtp project ())) (#:rtproject:build-references project) project) (error 'build-rt-project "this project is not defined" name))))
(loader'((fentry activate-rt-project subr2)
(entry activate-rt-project subr2)
(push a2)
(push a1)
(jcall find-rt-project)
(push a1)
(btnil a1 101)
(btnil (& 2) 104)
(hpxmov a1 '1 a4)
(push a4)
105
(bfcons (& 0) 106)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(mov (& 4) a2)
(mov (& 0) a1)
(jcall activate-rt-project)
(adjstk '1)
(bra 105)
106
(adjstk '1)
104
(mov (& 2) a2)
(mov (& 1) a1)
(jcall load-rt-project)
(mov (& 0) a1)
(call #:rtproject:activate)
(mov (& 0) a1)
(adjstk '3)
(return)
101
(mov (& 1) a3)
(mov '"this project is not defined" a2)
(mov 'activate-rt-project a1)
(adjstk '3)
(jmp error)
))
(loader'((fentry #:rtproject:gcalarm subr0)
(entry #:rtproject:gcalarm subr0)
(mov nil a1)
(return)
))
(loader'((fentry #:rtproject:gc-before-alarm subr0)
(entry #:rtproject:gc-before-alarm subr0)
(mov nil a1)
(return)
))
(loader'((entry #:rtproject:check-directory subr2)
(push a2)
(push a1)
(jcall directoryp)
(bfnil a1 101)
(btnil (& 1) 102)
(mov (& 0) a3)
(mov '"directory doesn't exist" a2)
(mov 'check-directory a1)
(adjstk '2)
(jmp error)
102
(push (@ 104))
(mov '0 a4)
(jmp outchan)
104
(eval ())
(push a1)
(push (@ 105))
(push dlink)
(push prot)
(stack dlink)
(push (@ 107))
(push nil)
(mov '1 a4)
(jmp outchan)
107
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (& 12) a3)
(mov '"directory doesn't exist" a2)
(mov 'check-directory a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 106) a3)
105
(push a3)
(push a2)
(push (@ 108))
(push (& 4))
(mov '1 a4)
(jmp outchan)
108
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
106
(eval ())
(adjstk '1)
(mov nil a1)
(adjstk '2)
(return)
101
(adjstk '2)
(return)
))
(loader'((entry #:rtproject:check-directories nsubr)
(diff '1 a4)
(jcall #:llcp:nlist)
(push a1)
(mov (car a1) (& 0))
(hpxmov (& 1) '2 a4)
(btnil a4 102)
(hpxmov (& 1) '2 a1)
(mov (& 0) a2)
(call #:rtproject:check-directory)
102
(hpxmov (& 1) '5 a1)
(mov (& 0) a2)
(call #:rtproject:check-directory)
(hpxmov (& 1) '3 a4)
(push a4)
103
(bfcons (& 0) 104)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(mov (& 2) a2)
(mov (& 0) a1)
(call #:rtproject:check-directory)
(adjstk '1)
(bra 103)
104
(adjstk '1)
(hpxmov (& 1) '9 a4)
(btnil a4 106)
(hpxmov (& 1) '9 a1)
(mov (& 0) a2)
(call #:rtproject:check-directory)
106
(hpxmov (& 1) '7 a4)
(btnil a4 108)
(hpxmov (& 1) '7 a1)
(mov (& 0) a2)
(call #:rtproject:check-directory)
108
(hpxmov (& 1) '3 a4)
(bfnil a4 110)
(hpxmov (& 1) '9 a4)
(bfnil a4 110)
(hpxmov (& 1) '7 a4)
(bfnil a4 110)
(btnil (& 0) 111)
(hpxmov (& 1) '0 a3)
(mov '"No directory has been specified for this project" a2)
(mov 'define-rt-project a1)
(jcall error)
(bra 110)
111
(push (@ 113))
(mov '0 a4)
(jmp outchan)
113
(eval ())
(push a1)
(push (@ 114))
(push dlink)
(push prot)
(stack dlink)
(push (@ 116))
(push nil)
(mov '1 a4)
(jmp outchan)
116
(eval ())
(push nil)
(push (cvalq #:system:print-for-read))
(mov (& 1) (cvalq #:system:print-for-read))
(push '1)
(push '(#:system:print-for-read))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(hpxmov (& 13) '0 a3)
(mov '"No directory has been specified for this project" a2)
(mov 'define-rt-project a1)
(jcall printerror)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:print-for-read))
(adjstk '8)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 115) a3)
114
(push a3)
(push a2)
(push (@ 117))
(push (& 4))
(mov '1 a4)
(jmp outchan)
117
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
115
(eval ())
(adjstk '1)
110
(hpxmov (& 1) '4 a1)
(mov (& 0) a2)
(call #:rtproject:check-directory)
(mov 'check-directories a1)
(adjstk '2)
(return)
))
'(defun #:rtproject:simplify-eq (list) (if list (cons (car list) (#:rtproject:simplify-eq (delq (car list) list)))))
(loader'((entry #:rtproject:simplify-equal subr1)
(btnil a1 101)
(push (car a1))
(mov a1 a2)
(mov (car a1) a1)
(jcall delete)
(call #:rtproject:simplify-equal)
(mov a1 a2)
(pop a1)
(jmp cons)
101
(mov nil a1)
(return)
))
'(defun #:rtproject:capitalize-string (name) (assert-values name (string non-null-symbol) '#:rtproject:capitalize-word) (let ((list (mapcar 'lowercase (explode name)))) (rplaca list (uppercase (car list))) (let ((#:system:read-case-flag t)) (setq name (string (implode list))))))
'(defun #:rtproject:compute-main-c-object-name (project) (if (#:rtproject:c-object-name project) (string (#:rtproject:c-object-name project)) (catenate (#:rtproject:capitalize-string (#:rtproject:name project)) "O")))
'(defun #:rtproject:union-order (l1 l2) (let (x (l (nreverse l1))) (while l2 (setq x (nextl l2)) (unless (member x l) (setq l (cons x l)))) (nreverse l)))
(loader '((end)))

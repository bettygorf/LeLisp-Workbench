;;; GELL 15.26: elaboration file for the module: hash
;;;             translation done: "Thu Jul   8 93 21:26:13 "

(with ((outchan ()))
	(print ";Loading elaboration file: hash.le"))
(unless (boundp '#:module:compiled-list)
	(setq #:module:compiled-list ()))
(newl #:module:compiled-list 'hash)
(setq #:system:read-case-flag t)

(defcelaborate "GZhash" "Thu Jul   8 93 21:26:13 "

'((#:hash-table:vect . nsubr) (hash-table-p . subr1) (#:hash-table:eval . subr1) (#:hash-table:prin . subr1) (make-hash-table-eq . nsubr) (make-hash-table-equal . nsubr) (make-hash-table . nsubr) (sxhash . subr1) (gethash . nsubr) (puthash . subr3) (inchash . nsubr) (dechash . nsubr) (remhash . subr2) (maphash . subr2) (clrhash . subr1) (hash-table-count . subr1) (hash-table-values . subr1) (#:hash-table:print-stat . subr2))

#[eq #[] #:hash-table:default-lowest-size #:hash-table:default-max-bucket-length #:hash-table:default-growing-threshold #:hash-table:default-growing-factor #:hash-table:default-shrinking-threshold #:hash-table:default-shrinking-factor vector hash-table #:hash-table:vect #:system:structaccess type-of t #:system:print-for-read (#:system:print-for-read) lambda "#" "H" catenate prin (#:system:print-for-read) "(" list (#:system:print-for-read) ")" "<" ">" make-hash-table-eq errwna make-hash-table-equ equal make-hash-table-equal make-hash-table #:hash-table:errbht errnia makevector #:hash-table:max-significative-element #:hash-table:result #:hash-table:count (#:hash-table:result #:hash-table:count) finish string #:system:locint #:llcp:exit quo 0. loc memory incradr hash-table-p sxhash #:hash-table:errnht assoc #:hash-table:default-max-number-of-entries erroob puthash acons #:hash-table:default-biggest-size complete #:llcp:block #:llcp:retfrom * fix / #:hash-table:debug "rehash: old hash-table" #:hash-table:print-stat "rehash: new hash-table" evenp (3 5 7 11 13) gethash #:llcp:errwna inchash |+| dechash |-| remhash funcall maphash <= clrhash hash-table-count hash-table-values print "  HT=   " "  list of size: " sortn (|+|) function apply "Pb with entries : :entries=" "  len=" " average size: " #:gell-resetfn:function-name #:gell-resetfn:function-n #:gell-resetfn:function-1 #:hash-table:eval #:hash-table:prin #:gell-resetfn:function-3 #:gell-resetfn:function-2]
)

(if (not (>= (version) 15.2)) (progn (error 'load 'erricf 'hash)))
(defvar #:sys-package:colon 'hash-table)
(add-feature 'hash-table)
(defvar #:hash-table:debug ())
(#:messages:put-message '#:hash-table:errnht 'french '"L'argument n'est pas une table de hachage" 'defmessage)
(#:messages:put-message '#:hash-table:errnht 'english '"not an Hash Table" 'defmessage)
'#:hash-table:errnht
(#:messages:put-message '#:hash-table:errbht 'french '"Le type de la table de hachage est inconnu" 'defmessage)
(#:messages:put-message '#:hash-table:errbht 'english '"Bad type for an Hash Table" 'defmessage)
'#:hash-table:errbht
(defvar #:hash-table:default-lowest-size 17)
(defvar #:hash-table:default-biggest-size 9239)
(defvar #:hash-table:default-max-number-of-entries 32767)
(defvar #:hash-table:default-max-bucket-length 12)
(defvar #:hash-table:default-growing-threshold (scale #:hash-table:default-max-bucket-length 1 2))
(defvar #:hash-table:default-growing-factor 1.6)
(defvar #:hash-table:default-shrinking-threshold 2)
(defvar #:hash-table:default-shrinking-factor 2.)
(defvar #:hash-table:max-significative-element 10)
(putprop 'hash-table '(('eq #[] 0 (dynamic #:hash-table:default-lowest-size) (dynamic #:hash-table:default-max-bucket-length) (dynamic #:hash-table:default-growing-threshold) (dynamic #:hash-table:default-growing-factor) (dynamic #:hash-table:default-shrinking-threshold) (dynamic #:hash-table:default-shrinking-factor)) type vect entries size max-bucket-length growing-threshold growing-factor shrinking-threshold shrinking-factor) 'defstruct)
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:type '#:hash-table:type 'setf-inverse) '#:hash-table:type)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:type (struct . valeur) (ifn valeur (list 'vref struct 0) (list 'vset struct 0 (car valeur))))))
(defcsetfn '#:hash-table:vect "GZhash" 0)
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:vect '#:hash-table:vect 'setf-inverse) '#:hash-table:vect)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:vect (struct . valeur) (ifn valeur (list 'vref struct 1) (list 'vset struct 1 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:entries '#:hash-table:entries 'setf-inverse) '#:hash-table:entries)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:entries (struct . valeur) (ifn valeur (list 'vref struct 2) (list 'vset struct 2 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:size '#:hash-table:size 'setf-inverse) '#:hash-table:size)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:size (struct . valeur) (ifn valeur (list 'vref struct 3) (list 'vset struct 3 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:max-bucket-length '#:hash-table:max-bucket-length 'setf-inverse) '#:hash-table:max-bucket-length)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:max-bucket-length (struct . valeur) (ifn valeur (list 'vref struct 4) (list 'vset struct 4 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:growing-threshold '#:hash-table:growing-threshold 'setf-inverse) '#:hash-table:growing-threshold)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:growing-threshold (struct . valeur) (ifn valeur (list 'vref struct 5) (list 'vset struct 5 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:growing-factor '#:hash-table:growing-factor 'setf-inverse) '#:hash-table:growing-factor)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:growing-factor (struct . valeur) (ifn valeur (list 'vref struct 6) (list 'vset struct 6 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:shrinking-threshold '#:hash-table:shrinking-threshold 'setf-inverse) '#:hash-table:shrinking-threshold)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:shrinking-threshold (struct . valeur) (ifn valeur (list 'vref struct 7) (list 'vset struct 7 (car valeur))))))
(if (featurep 'setf) (progn (progn (putprop '#:hash-table:shrinking-factor '#:hash-table:shrinking-factor 'setf-inverse) '#:hash-table:shrinking-factor)))
(if (featurep 'compiler) (progn (defmacro-open #:hash-table:shrinking-factor (struct . valeur) (ifn valeur (list 'vref struct 8) (list 'vset struct 8 (car valeur))))))
(putprop 'gethash (lambda (value key hash-table) (list 'puthash key hash-table value)) 'setf-expander)
'gethash
(defcsetfn 'hash-table-p "GZhash" 1)
(defcsetfn '#:hash-table:eval "GZhash" 2)
(defcsetfn '#:hash-table:prin "GZhash" 3)
(defsharp H (size) (let ((#:system:read-case-flag ())) (let ((lst (read))) (if (atom lst) (error '|#H| 'errsxt "not printed properly") (let ((hash-table (make-hash-table size (car lst)))) (mapc (lambda ((key value)) (setf (gethash key hash-table) value)) (cdr lst)) (list hash-table))))))
(defcsetfn 'make-hash-table-eq "GZhash" 4)
(defcsetfn 'make-hash-table-equal "GZhash" 5)
(defcsetfn 'make-hash-table "GZhash" 6)
(defcsetfn 'sxhash "GZhash" 7)
(defcsetfn 'gethash "GZhash" 8)
(defcsetfn 'puthash "GZhash" 9)
(defcsetfn 'inchash "GZhash" 10)
(defcsetfn 'dechash "GZhash" 11)
(defcsetfn 'remhash "GZhash" 12)
(defcsetfn 'maphash "GZhash" 13)
(defcsetfn 'clrhash "GZhash" 14)
(defcsetfn 'hash-table-count "GZhash" 15)
(defcsetfn 'hash-table-values "GZhash" 16)
(defcsetfn '#:hash-table:print-stat "GZhash" 17)

(defccheck '(apply function sortn print <= funcall |-| |+| #:llcp:errwna evenp puthash #:hash-table:print-stat / fix * #:llcp:retfrom equal #:llcp:block acons assoc sxhash hash-table-p incradr memory loc quo #:llcp:exit #:system:locint string makevector list prin catenate type-of #:system:structaccess vector))

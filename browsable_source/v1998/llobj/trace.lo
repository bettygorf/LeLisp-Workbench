(loader '((title |trace.lo|)))
(if (not (>= (version) 15.2)) (progn (error 'load 'erricf 'trace)))
(add-feature 'debug)
(defvar #:sys-package:colon 'trace)
(#:messages:put-message '#:trace:errtnb 'french '"Je ne sais pas tracer une fonction &NOBIND" 'defmessage)
(#:messages:put-message '#:trace:errtnb 'english '"I don't know how to trace an &NOBIND function" 'defmessage)
'#:trace:errtnb
(#:messages:put-message '#:trace:errcnt 'french '"Je ne peux pas tracer" 'defmessage)
(#:messages:put-message '#:trace:errcnt 'english '"I can't trace" 'defmessage)
'#:trace:errcnt
(#:messages:put-message '#:trace:errknt 'french '"Je ne sais pas tracer une fonction de ce type" 'defmessage)
(#:messages:put-message '#:trace:errknt 'english '"I don't know trace a function of this type" 'defmessage)
'#:trace:errknt
(#:messages:put-message '#:trace:errntf 'french '"cette fonction n'e'tait pas trace'e" 'defmessage)
(#:messages:put-message '#:trace:errntf 'english '"this function wasn't traced" 'defmessage)
'#:trace:errntf
(defvar #:system:debug ())
(defvar *trace-input* ())
(defvar *trace-output* ())
(defvar #:step:auto-step ())
(loader'((fentry #:trace:output dmsubr)
(entry #:trace:output dmsubr)
(push (@ 101))
(push 'with)
(push '((outchan *trace-output*)))
(push a1)
(mov '3 a4)
(jmp mcons)
101
(eval ())
(return)
))
(defvar #:trace:trace ())
(defvar #:trace:last-untraced ())
(defvar #:trace:untracable '(cstep step unstep quote arg =))
(loader'((entry #:trace:flat subr1)
(push nil)
(push (cvalq r))
(mov (& 1) (cvalq r))
(push '1)
(push '(r))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(call #:trace:flat-aux)
(mov (cvalq r) a1)
(jcall reverse)
(mov (& 1) dlink)
(mov (& 6) (cvalq r))
(adjstk '8)
(return)
))
(loader'((entry #:trace:flat-aux subr1)
(push a1)
(bfnil a1 101)
(mov nil a1)
(adjstk '1)
(return)
101
(btcons a1 103)
(mov (cvalq r) a2)
(jcall cons)
(mov a1 (cvalq r))
(adjstk '1)
(return)
103
(mov (car a1) a1)
(call #:trace:flat-aux)
(mov (& 0) a1)
(mov (cdr a1) a1)
(adjstk '1)
(bra #:trace:flat-aux)
))
(defvar tracewindow ())
(defvar #:trace:windowp t)
(loader'((fentry trace fsubr)
(entry trace fsubr)
(push a1)
(btnil a1 101)
(push a1)
103
(bfcons (& 0) 104)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(jcall #:trace:trace-one)
(bra 103)
104
(adjstk '1)
(btnil (cvalq #:trace:trace) 106)
(mov 'window a1)
(jcall featurep)
(btnil a1 106)
(bfnil (cvalq tracewindow) 106)
(btnil (cvalq #:trace:windowp) 106)
(push (@ 107))
(push '#:window:tty)
(push (@ 108))
(mov '0 a4)
(jmp bitxmax)
108
(eval ())
(quo '2 a1)
(push a1)
(jcall font-height)
(times '3 a1)
(push a1)
(push (@ 109))
(mov '0 a4)
(jmp bitxmax)
109
(eval ())
(quo '2 a1)
(push a1)
(push (@ 110))
(mov '0 a4)
(jmp bitymax)
110
(eval ())
(push a1)
(push '"Le-Lisp : Trace")
(push '0)
(push '1)
(mov '8 a4)
(jmp create-window)
107
(eval ())
(mov a1 (cvalq tracewindow))
106
(mov (& 0) a1)
(adjstk '1)
(return)
101
(mov (cvalq #:trace:trace) a1)
(adjstk '1)
(return)
))
(loader'((fentry untrace fsubr)
(entry untrace fsubr)
(push a1)
(mov a1 a4)
(bfnil a4 101)
(mov (cvalq #:trace:trace) (& 0))
(mov (cvalq #:trace:trace) a4)
101
(mov a4 (cvalq #:trace:last-untraced))
(push a4)
102
(bfcons (& 0) 103)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(jcall #:trace:untrace-one)
(bra 102)
103
(adjstk '1)
(bfnil (cvalq #:trace:trace) 105)
(mov 'window a1)
(jcall featurep)
(btnil a1 105)
(btnil (cvalq tracewindow) 105)
(mov (cvalq tracewindow) a1)
(jcall kill-window)
(mov nil (cvalq tracewindow))
105
(mov (& 0) a1)
(adjstk '1)
(return)
))
(loader'((fentry #:trace:untrace-one subr1)
(entry #:trace:untrace-one subr1)
(push a1)
(mov 'trace a2)
(jcall getprop)
(push a1)
(btcons a1 101)
(mov (& 1) a3)
(mov '#:trace:errntf a2)
(mov 'untrace a1)
(adjstk '2)
(jmp printerror)
101
(mov 'resetfn&trace a2)
(mov (& 1) a1)
(jcall getprop)
(btnil a1 103)
(mov (& 0) a2)
(mov (cdr a2) a3)
(mov (car a2) a2)
(mov (& 1) a1)
(jcall resetfn)
(mov 'resetfn&trace a2)
(mov (& 1) a1)
(jcall remprop)
(bra 104)
103
(mov 'resetfn a2)
(mov (& 1) a1)
(jcall getprop)
(btnil a1 105)
(mov 'resetfn a2)
(mov (& 1) a1)
(jcall remprop)
(mov (& 0) a2)
(mov (cdr a2) a3)
(mov (car a2) a2)
(mov (& 1) a1)
(jcall setfn)
(bra 104)
105
(mov (& 0) a2)
(mov (cdr a2) a3)
(mov (car a2) a2)
(mov (& 1) a1)
(jcall setfn)
104
(mov 'trace a2)
(mov (& 1) a1)
(jcall remprop)
(mov (cvalq #:trace:trace) a2)
(mov (& 1) a1)
(jcall delq)
(mov a1 (cvalq #:trace:trace))
(adjstk '2)
(return)
))
(loader'((entry default-specif subr1)
(cabne a1 'entry 102)
(push (@ 103))
(push '#:trace:output)
(push (@ 104))
(push 'print)
(push (@ 105))
(push 'quote)
(push (cvalq #:trace:fct))
(mov '2 a4)
(jmp list)
105
(eval ())
(push a1)
(push '" ---> ")
(push (@ 108))
(push '"subr")
(push (cvalq #:trace:ftype))
(mov '2 a4)
(jmp index)
108
(eval ())
(btnil a1 106)
(mov (cvalq #:trace:larg) a1)
(call #:trace:flat)
(push a1)
(push nil)
109
(bfcons (& 1) 110)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(push (@ 111))
(push (& 1))
(push '" ")
(mov '2 a4)
(jmp list)
111
(eval ())
(adjstk '1)
(mov (& 0) a2)
(jcall nreconc)
(mov a1 (& 0))
(bra 109)
110
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(mov a1 a4)
(bra 107)
106
(mov (cvalq #:trace:larg) a1)
(call #:trace:flat)
(push a1)
(push nil)
112
(bfcons (& 1) 113)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(push (@ 114))
(mov (& 1) a1)
(jcall kwote)
(push a1)
(push '"=")
(push (& 3))
(push '" ")
(mov '4 a4)
(jmp list)
114
(eval ())
(adjstk '1)
(mov (& 0) a2)
(jcall nreconc)
(mov a1 (& 0))
(bra 112)
113
(mov (& 0) a1)
(jcall nreverse)
(adjstk '2)
(mov a1 a4)
107
(push a4)
(mov '4 a4)
(jmp mcons)
104
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
103
(eval ())
(jmp ncons)
102
(cabne a1 'exit 115)
(push (@ 116))
(push '#:trace:output)
(push (@ 117))
(push 'print)
(push (@ 118))
(push 'quote)
(push (cvalq #:trace:fct))
(mov '2 a4)
(jmp list)
118
(eval ())
(push a1)
(push '(" <--- " #:trace:value))
(mov '3 a4)
(jmp mcons)
117
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
116
(eval ())
(jmp ncons)
115
(cabne a1 'when 119)
(mov '(t) a1)
(return)
119
(cabne a1 'break 120)
(mov nil a1)
(return)
120
(cabne a1 'step 121)
(mov nil a1)
(return)
121
(mov nil a1)
(return)
))
(loader'((entry parse-specif subr1)
(push a1)
(push '(entry exit when break step))
(push nil)
101
(bfcons (& 1) 102)
(mov (& 1) a4)
(mov (cdr a4) (& 1))
(push (car a4))
(mov (& 3) a2)
(mov (& 0) a1)
(jcall assq)
(bfnil a1 103)
(mov (& 0) a1)
(call default-specif)
(mov a1 a2)
(mov (& 0) a1)
(jcall cons)
103
(adjstk '1)
(mov (& 0) a2)
(jcall cons)
(mov a1 (& 0))
(bra 101)
102
(mov (& 0) a1)
(adjstk '3)
(jmp nreverse)
))
(defvar #:trace:not-in-trace-flag t)
(defvar #:trace:step-in-trace-flag ())
(synonym '#:trace:if 'if)
(synonym '#:trace:let 'let)
(synonym '#:trace:when 'when)
(synonym '#:trace:with 'with)
(synonym '#:trace:progn 'progn)
(synonym '#:trace:itsoft 'itsoft)
(synonym '#:trace:and 'and)
(synonym '#:trace:or 'or)
(synonym '#:trace:call 'call)
(synonym '#:trace:calln 'calln)
(synonym '#:trace:boundp 'boundp)
(synonym '#:trace:eval 'eval)
(synonym '#:trace:traceval 'traceval)
(synonym '#:trace:eprogn 'eprogn)
(loader'((entry build-tracing-fval subr1)
(push a1)
(push (@ 101))
(push (cvalq #:trace:larg))
(push (@ 102))
(push 'unstep)
(push (@ 103))
(push '#:trace:if)
(push '#:trace:not-in-trace-flag)
(push (@ 104))
(push '#:trace:let)
(push '((#:trace:not-in-trace-flag ())))
(push '(setq #:trace:step-in-trace-flag ()))
(push (@ 105))
(push '#:trace:when)
(mov a1 a2)
(mov 'when a1)
(jcall cassq)
(push (car a1))
(mov 'window a1)
(jcall featurep)
(btnil a1 106)
(btnil (cvalq #:trace:windowp) 106)
(push (@ 108))
(push '#:trace:with)
(push (@ 109))
(push 'current-window)
(push 'tracewindow)
(mov '2 a4)
(jmp list)
109
(eval ())
(jcall ncons)
(push a1)
(mov (& 17) a2)
(mov 'entry a1)
(jcall cassq)
(push a1)
(mov '3 a4)
(jmp mcons)
108
(eval ())
(mov a1 a4)
(bra 107)
106
(mov (& 14) a2)
(mov 'entry a1)
(jcall cassq)
(mov a1 a2)
(mov '#:trace:progn a1)
(jcall cons)
(mov a1 a4)
107
(push a4)
(push (@ 110))
(push '#:trace:when)
(mov (& 17) a2)
(mov 'break a1)
(jcall cassq)
(push (car a1))
(push (@ 111))
(push 'let)
(push '((#:trace:not-in-trace-flag t) (#:system:debug t)))
(push (@ 112))
(push '#:trace:itsoft)
(push ''syserror)
(push (@ 113))
(push 'quote)
(mov '(break tracebreak) a2)
(mov (cvalq #:trace:fct) a1)
(jcall cons)
(push a1)
(mov '2 a4)
(jmp list)
113
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
112
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
111
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
110
(eval ())
(push a1)
(mov '4 a4)
(jmp list)
105
(eval ())
(push a1)
(push (@ 114))
(push '#:trace:let)
(push (@ 115))
(push '#:trace:value)
(push (@ 116))
(push '#:trace:if)
(push (@ 117))
(push '#:trace:and)
(mov (& 20) a2)
(mov 'when a1)
(jcall cassq)
(push (car a1))
(push (@ 118))
(push '#:trace:or)
(push '#:trace:step-in-trace-flag)
(mov (& 24) a2)
(mov 'step a1)
(jcall cassq)
(push (car a1))
(mov '3 a4)
(jmp list)
118
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
117
(eval ())
(push a1)
(push (@ 119))
(push '#:trace:let)
(push '((#:trace:not-in-trace-flag t)))
(push (@ 120))
(push 'step)
(push (cvalq #:trace:call))
(mov '2 a4)
(jmp list)
120
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
119
(eval ())
(push a1)
(push (@ 121))
(push '#:trace:let)
(push '((#:trace:not-in-trace-flag t)))
(push (@ 122))
(push 'cstep)
(push (cvalq #:trace:call))
(mov '2 a4)
(jmp list)
122
(eval ())
(push a1)
(mov '3 a4)
(jmp list)
121
(eval ())
(push a1)
(mov '4 a4)
(jmp list)
116
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
115
(eval ())
(jcall ncons)
(push a1)
(push (@ 123))
(push '#:trace:when)
(mov (& 17) a2)
(mov 'when a1)
(jcall cassq)
(push (car a1))
(mov 'window a1)
(jcall featurep)
(btnil a1 124)
(btnil (cvalq #:trace:windowp) 124)
(push (@ 126))
(push '#:trace:with)
(push (@ 127))
(push 'current-window)
(push 'tracewindow)
(mov '2 a4)
(jmp list)
127
(eval ())
(jcall ncons)
(push a1)
(mov (& 21) a2)
(mov 'exit a1)
(jcall cassq)
(push a1)
(mov '3 a4)
(jmp mcons)
126
(eval ())
(mov a1 a4)
(bra 125)
124
(mov (& 18) a2)
(mov 'exit a1)
(jcall cassq)
(mov a1 a2)
(mov '#:trace:progn a1)
(jcall cons)
(mov a1 a4)
125
(push a4)
(mov '3 a4)
(jmp list)
123
(eval ())
(push a1)
(push '(#:trace:value))
(mov '4 a4)
(jmp mcons)
114
(eval ())
(push a1)
(mov '5 a4)
(jmp list)
104
(eval ())
(push a1)
(push (@ 128))
(push 'cstep)
(push (cvalq #:trace:call))
(mov '2 a4)
(jmp list)
128
(eval ())
(push a1)
(mov '4 a4)
(jmp list)
103
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
102
(eval ())
(push a1)
(mov '2 a4)
(jmp list)
101
(eval ())
(adjstk '1)
(return)
))
(defvar #:trace:fct)
(defvar #:trace:ftype)
(defvar #:trace:larg)
(defvar #:trace:call)
(loader'((fentry #:trace:trace-one subr1)
(entry #:trace:trace-one subr1)
(push (cvalq #:trace:fct))
(mov a1 (cvalq #:trace:fct))
(push '1)
(push '(#:trace:fct))
(push (@ #:trace:trace-one))
(push llink)
(mov nil llink)
(push dlink)
(push cbindn)
(stack dlink)
(push nil)
(push nil)
(bfcons a1 102)
(mov (cdr a1) (& 1))
(mov (car a1) (cvalq #:trace:fct))
102
(mov (cvalq #:trace:untracable) a2)
(mov (cvalq #:trace:fct) a1)
(jcall memq)
(btnil a1 104)
(mov (cvalq #:trace:fct) a3)
(mov '#:trace:errcnt a2)
(mov 'trace a1)
(jcall error)
104
(mov (cvalq #:trace:fct) a1)
(jcall valfn)
(bfcons a1 106)
(mov (cvalq #:trace:fct) a1)
(jcall valfn)
(cabne '&nobind (car a1) 106)
(mov (cvalq #:trace:fct) a3)
(mov '#:trace:errtnb a2)
(mov 'trace a1)
(jcall error)
106
(mov (cvalq #:trace:trace) a2)
(mov (cvalq #:trace:fct) a1)
(jcall memq)
(btnil a1 108)
(mov (cvalq #:trace:fct) a1)
(jcall #:trace:untrace-one)
108
(mov 'resetfn a2)
(mov (cvalq #:trace:fct) a1)
(jcall getprop)
(mov (car a1) a4)
(bfnil a4 109)
(mov (cvalq #:trace:fct) a1)
(jcall typefn)
(mov a1 a4)
109
(push a4)
(mov 'resetfn a2)
(mov (cvalq #:trace:fct) a1)
(jcall getprop)
(mov (cdr a1) a3)
(bfnil a3 110)
(mov (cvalq #:trace:fct) a1)
(jcall valfn)
(mov a1 a3)
110
(push nil)
(push nil)
(push a3)
(push (cvalq #:trace:call))
(mov (& 2) (cvalq #:trace:call))
(push (cvalq #:trace:larg))
(mov (& 4) (cvalq #:trace:larg))
(push (cvalq #:trace:ftype))
(mov (& 6) (cvalq #:trace:ftype))
(push '3)
(push '(#:trace:call #:trace:larg #:trace:ftype))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov 'resetfn a2)
(mov (cvalq #:trace:fct) a1)
(jcall getprop)
(btnil a1 112)
(mov (& 13) a2)
(mov '(t resetfn&trace) a1)
(jcall cons)
(mov a1 (& 13))
112
(mov (cvalq #:trace:ftype) a1)
(cabeq a1 'expr 115)
(cabeq a1 'fexpr 115)
(cabeq a1 'macro 115)
(cabne a1 'dmacro 114)
115
(mov (& 9) a4)
(mov (car a4) (cvalq #:trace:larg))
(mov (cdr a4) a2)
(mov '#:trace:progn a1)
(jcall cons)
(mov a1 (cvalq #:trace:call))
(bra 113)
114
(cabne a1 'subr0 116)
(mov nil (cvalq #:trace:larg))
(push (@ 117))
(push '#:trace:call)
(push (@ 118))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
118
(eval ())
(push a1)
(push '(() () ()))
(mov '3 a4)
(jmp mcons)
117
(eval ())
(mov a1 (cvalq #:trace:call))
(bra 113)
116
(cabne a1 'subr1 119)
120
(mov '(#:trace:arg1) (cvalq #:trace:larg))
(push (@ 121))
(push '#:trace:call)
(push (@ 122))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
122
(eval ())
(push a1)
(push '(#:trace:arg1 () ()))
(mov '3 a4)
(jmp mcons)
121
(eval ())
(mov a1 (cvalq #:trace:call))
(bra 113)
119
(cabne a1 'subr2 123)
(mov '(#:trace:arg1 #:trace:arg2) (cvalq #:trace:larg))
(push (@ 124))
(push '#:trace:call)
(push (@ 125))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
125
(eval ())
(push a1)
(push '(#:trace:arg1 #:trace:arg2 ()))
(mov '3 a4)
(jmp mcons)
124
(eval ())
(mov a1 (cvalq #:trace:call))
(bra 113)
123
(cabne a1 'subr3 126)
(mov '(#:trace:arg1 #:trace:arg2 #:trace:arg3) (cvalq #:trace:larg))
(push (@ 127))
(push '#:trace:call)
(push (@ 128))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
128
(eval ())
(push a1)
(push '(#:trace:arg1 #:trace:arg2 #:trace:arg3))
(mov '3 a4)
(jmp mcons)
127
(eval ())
(mov a1 (cvalq #:trace:call))
(bra 113)
126
(cabeq a1 'fsubr 130)
(cabeq a1 'msubr 130)
(cabne a1 'dmsubr 129)
130
(mov '#:trace:arg1 (cvalq #:trace:larg))
(push (@ 131))
(push '#:trace:call)
(push (@ 132))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
132
(eval ())
(push a1)
(push '(#:trace:arg1 () ()))
(mov '3 a4)
(jmp mcons)
131
(eval ())
(mov a1 (cvalq #:trace:call))
(bra 113)
129
(cabne a1 'nsubr 113)
(mov '#:trace:arg1 (cvalq #:trace:larg))
(push (@ 134))
(push '#:trace:calln)
(push (@ 135))
(push 'quote)
(push (& 13))
(mov '2 a4)
(jmp list)
135
(eval ())
(push a1)
(push '(#:trace:arg1))
(mov '3 a4)
(jmp mcons)
134
(eval ())
(mov a1 (cvalq #:trace:call))
113
(bfnil (cvalq #:trace:ftype) 136)
(mov (cvalq #:trace:fct) a3)
(mov 'errunk a2)
(mov 'trace a1)
(jcall printerror)
(bra 137)
136
(mov (cvalq #:trace:ftype) a4)
(cabeq a4 'expr 138)
(cabeq a4 'fexpr 138)
(cabeq a4 'macro 138)
(cabeq a4 'dmacro 138)
(cabeq a4 'msubr 138)
(cabeq a4 'dmsubr 138)
(cabeq a4 'subr0 138)
(cabeq a4 'subr1 138)
(cabeq a4 'subr2 138)
(cabeq a4 'subr3 138)
(cabeq a4 'fsubr 138)
(cabeq a4 'nsubr 138)
(push (@ 140))
(push (cvalq #:trace:fct))
(push a4)
(mov '2 a4)
(jmp list)
140
(eval ())
(mov a1 a3)
(mov '#:trace:errknt a2)
(mov 'trace a1)
(jcall printerror)
(bra 137)
138
(push (@ 141))
(mov (& 10) a2)
(mov a4 a1)
(jcall cons)
(push a1)
(push 'trace)
(mov '2 a4)
(jmp list)
141
(eval ())
(mov (& 13) a2)
(jcall cons)
(mov a1 (& 13))
(push (cvalq #:trace:fct))
(mov '(expr fexpr macro dmacro) a2)
(mov (cvalq #:trace:ftype) a1)
(jcall memq)
(mov (car a1) a2)
(bfnil a2 142)
(mov '((subr1 . expr) (subr2 . expr) (subr3 . expr) (subr0 . expr) (fsubr . fexpr) (nsubr . expr) (msubr . macro) (dmsubr . dmacro)) a2)
(mov (cvalq #:trace:ftype) a1)
(jcall cassq)
(mov a1 a2)
142
(push a2)
(mov (& 16) a1)
(call parse-specif)
(call build-tracing-fval)
(mov a1 a3)
(pop a2)
(pop a1)
(jcall resetfn)
(mov (cvalq #:trace:trace) a2)
(mov (cvalq #:trace:fct) a1)
(jcall cons)
(mov a1 (cvalq #:trace:trace))
(push (& 13))
143
(bfcons (& 0) 144)
(mov (& 0) a4)
(mov (cdr a4) (& 0))
(push (car a4))
(mov (& 0) a4)
(mov (car a4) (& 0))
(mov (cdr a4) a4)
(mov (car a4) a4)
(mov a4 a3)
(mov (& 0) a2)
(mov (cvalq #:trace:fct) a1)
(jcall putprop)
(adjstk '1)
(bra 143)
144
(mov nil a1)
(adjstk '1)
137
(mov (& 1) dlink)
(mov (& 6) (cvalq #:trace:ftype))
(mov (& 7) (cvalq #:trace:larg))
(mov (& 8) (cvalq #:trace:call))
(adjstk '15)
(mov (& 1) dlink)
(mov (& 2) llink)
(mov (& 6) (cvalq #:trace:fct))
(adjstk '7)
(return)
))
(setq #:sys-package:colon 'step)
(#:messages:put-message '#:step:errnonobind 'french '"je ne peux pas suivre une fonction &NOBIND" 'defmessage)
(#:messages:put-message '#:step:errnonobind 'english '"I can't step an &NOBIND function" 'defmessage)
'#:step:errnonobind
(#:messages:put-message '#:step:errnosendwindow 'french '"je ne sais pas suivre SEND dans une fene^tre graphique" 'defmessage)
(#:messages:put-message '#:step:errnosendwindow 'english '"I can't step SEND into graphic window" 'defmessage)
'#:step:errnosendwindow
(#:messages:put-message '#:step:help1 'french '";Les commandes de pas a pas sont : " 'defmessage)
(#:messages:put-message '#:step:help1 'english '";Commands for step are : " 'defmessage)
'#:step:help1
(#:messages:put-message '#:step:help2 'french '";   CR  pour passer a l'expression suivante" 'defmessage)
(#:messages:put-message '#:step:help2 'english '";   CR  go to next expression" 'defmessage)
'#:step:help2
(#:messages:put-message '#:step:help3 'french '";   .   pour voir l'expression courante" 'defmessage)
(#:messages:put-message '#:step:help3 'english '";   .   see current expression" 'defmessage)
'#:step:help3
(#:messages:put-message '#:step:help4 'french '";   <   pour evaluer sans pas a pas et y revenir" 'defmessage)
(#:messages:put-message '#:step:help4 'english '";   <   evaluate without step and come back" 'defmessage)
'#:step:help4
(#:messages:put-message '#:step:help5 'french '";   q   retour au toplevel" 'defmessage)
(#:messages:put-message '#:step:help5 'english '";   q   return to toplevel" 'defmessage)
'#:step:help5
(#:messages:put-message '#:step:help6 'french '";   h   pour avoir l'historique du pas a pas" 'defmessage)
(#:messages:put-message '#:step:help6 'english '";   h   view history" 'defmessage)
'#:step:help6
(#:messages:put-message '#:step:help7 'french '";   ?   pour avoir ce texte ...." 'defmessage)
(#:messages:put-message '#:step:help7 'english '";   ?   this message ..." 'defmessage)
'#:step:help7
(defvar #:step:depth 0)
(defvar #:step:value ())
(defvar #:step:speak t)
(defvar #:step:history ())
(defvar #:step:exp)
(makunbound '#:step:speak)
(loader'((fentry step fsubr)
(entry step fsubr)
(mov (car a1) a1)
(push (cvalq #:step:exp))
(mov a1 (cvalq #:step:exp))
(push '1)
(push '(#:step:exp))
(push (@ step))
(push llink)
(mov nil llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (cvalq #:sys-package:itsoft) a2)
(mov 'step a1)
(jcall cons)
(push '0)
(push nil)
(push 't)
(push (cvalq #:trace:trace))
(push nil)
(push (cvalq #:sys-package:itsoft))
(mov a1 (cvalq #:sys-package:itsoft))
(push (cvalq #:step:history))
(mov (& 2) (cvalq #:step:history))
(push (cvalq #:trace:trace))
(mov (& 4) (cvalq #:trace:trace))
(push (cvalq #:step:speak))
(mov (& 6) (cvalq #:step:speak))
(push (cvalq #:step:value))
(mov (& 8) (cvalq #:step:value))
(push (cvalq #:step:depth))
(mov (& 10) (cvalq #:step:depth))
(push '6)
(push '(#:sys-package:itsoft #:step:history #:trace:trace #:step:speak #:step:value #:step:depth))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 101))
(push 'step)
(push dlink)
(push tag)
(stack dlink)
(push (@ 102))
(push (@ 103))
(push 'progn)
(push (cvalq #:step:exp))
(mov '2 a4)
(jmp list)
103
(eval ())
(push a1)
(mov '1 a4)
(jmp #:trace:traceval)
102
(eval ())
(mov (& 1) dlink)
(adjstk '4)
101
(eval ())
(mov (& 1) dlink)
(mov (& 6) (cvalq #:step:depth))
(mov (& 7) (cvalq #:step:value))
(mov (& 8) (cvalq #:step:speak))
(mov (& 9) (cvalq #:trace:trace))
(mov (& 10) (cvalq #:step:history))
(mov (& 11) (cvalq #:sys-package:itsoft))
(adjstk '17)
(mov (& 1) dlink)
(mov (& 2) llink)
(mov (& 6) (cvalq #:step:exp))
(adjstk '7)
(return)
))
(loader'((entry #:step:nobind? subr1)
(push a1)
(jcall consp)
(btnil a1 101)
(mov (& 0) a4)
(bfsymb (car a4) 102)
(mov (car a4) a1)
(jcall valfn)
(jcall consp)
(btnil a1 104)
(mov (& 0) a1)
(mov (car a1) a1)
(jcall valfn)
(mov (car a1) a2)
(mov '&nobind a1)
(adjstk '1)
(jmp eq)
104
(adjstk '1)
(return)
102
(mov (car a4) a1)
(jcall consp)
(btnil a1 105)
(mov (& 0) a2)
(mov (car a2) a2)
(mov (car a2) a2)
(mov 'lambda a1)
(jcall eq)
(btnil a1 105)
(mov (& 0) a2)
(mov (car a2) a2)
(mov (cdr a2) a2)
(mov (car a2) a2)
(mov '&nobind a1)
(adjstk '1)
(jmp eq)
105
(adjstk '1)
(return)
101
(adjstk '1)
(return)
))
(loader'((fentry #:step:stepeval subr2)
(entry #:step:stepeval subr2)
(push (cvalq #:step:env))
(mov a2 (cvalq #:step:env))
(push (cvalq #:step:forme))
(mov a1 (cvalq #:step:forme))
(push '2)
(push '(#:step:env #:step:forme))
(push (@ #:step:stepeval))
(push llink)
(mov nil llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov (cvalq #:step:depth) a1)
(jcall |1+|)
(push a1)
(mov (cvalq #:step:history) a2)
(mov (cvalq #:step:forme) a1)
(jcall cons)
(push (cvalq #:step:history))
(mov a1 (cvalq #:step:history))
(push (cvalq #:step:depth))
(mov (& 2) (cvalq #:step:depth))
(push '2)
(push '(#:step:history #:step:depth))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(bfcons (cvalq #:step:forme) 101)
(mov (cvalq #:step:forme) a4)
(cabne (car a4) 'unstep 101)
(push (@ 103))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp eval)
103
(eval ())
(bra 102)
101
(bfnil (cvalq #:step:speak) 104)
(push (@ 106))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp stepeval)
106
(eval ())
(bra 102)
104
(mov '46 a1)
(call #:step:steploop)
102
(mov (& 1) dlink)
(mov (& 6) (cvalq #:step:depth))
(mov (& 7) (cvalq #:step:history))
(adjstk '9)
(mov (& 1) dlink)
(mov (& 2) llink)
(mov (& 6) (cvalq #:step:forme))
(mov (& 7) (cvalq #:step:env))
(adjstk '8)
(return)
))
(loader'((fentry unstep fsubr)
(entry unstep fsubr)
(push (cvalq #:step:exp))
(mov a1 (cvalq #:step:exp))
(push '1)
(push '(#:step:exp))
(push (@ unstep))
(push llink)
(mov nil llink)
(push dlink)
(push cbindn)
(stack dlink)
(jcall #:trace:eprogn)
(mov (& 1) dlink)
(mov (& 2) llink)
(mov (& 6) (cvalq #:step:exp))
(adjstk '7)
(return)
))
(putprop 'unstep 'parano '#:complice:fvar)
(loader'((fentry cstep fsubr)
(entry cstep fsubr)
(mov (car a1) a1)
(push (cvalq #:step:exp))
(mov a1 (cvalq #:step:exp))
(push '1)
(push '(#:step:exp))
(push (@ cstep))
(push llink)
(mov nil llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov '((#:trace:and (#:trace:boundp '#:step:speak) #:step:speak) (#:trace:traceval #:step:exp) (#:trace:eval #:step:exp)) a1)
(jcall #:trace:if)
(mov (& 1) dlink)
(mov (& 2) llink)
(mov (& 6) (cvalq #:step:exp))
(adjstk '7)
(return)
))
(loader'((entry #:step:stepmargin subr1)
(push a1)
(push (@ 105))
(push a1)
(push '20)
(mov '2 a4)
(jmp <)
105
(eval ())
(btnil a1 103)
(mov (& 0) a4)
(bra 102)
103
(mov '21 a4)
(bra 102)
101
(push a4)
(push (@ 106))
(push '32)
(mov '1 a4)
(jmp princn)
106
(eval ())
(pop a4)
102
(sobgez a4 101)
(mov 't a1)
(adjstk '1)
(return)
))
(loader'((entry #:step:steploop subr1)
(push a1)
(btnil (cvalq #:step:auto-step) 102)
(mov 't (& 0))
102
(mov (& 0) a1)
(cabne a1 '46 104)
(push (@ 105))
(mov '0 a4)
(jmp outchan)
105
(eval ())
(push a1)
(push (@ 106))
(push dlink)
(push prot)
(stack dlink)
(push (@ 108))
(push (cvalq *trace-output*))
(mov '1 a4)
(jmp outchan)
108
(eval ())
(push (@ 109))
(mov '0 a4)
(jmp printlevel)
109
(eval ())
(push a1)
(push (@ 110))
(mov '0 a4)
(jmp printline)
110
(eval ())
(push a1)
(push (@ 111))
(push dlink)
(push prot)
(stack dlink)
(push (@ 113))
(push '3)
(mov '1 a4)
(jmp printlevel)
113
(eval ())
(push (@ 114))
(push '1)
(mov '1 a4)
(jmp printline)
114
(eval ())
(mov (cvalq #:step:depth) a1)
(call #:step:stepmargin)
(push (@ 115))
(push (cvalq #:step:depth))
(push '" -> ")
(push (cvalq #:step:forme))
(push '" step>")
(mov '4 a4)
(jmp prinflush)
115
(eval ())
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 112) a3)
111
(push a3)
(push a2)
(push (@ 116))
(push (& 4))
(mov '1 a4)
(jmp printline)
116
(eval ())
(push (@ 117))
(push (& 5))
(mov '1 a4)
(jmp printlevel)
117
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
112
(eval ())
(adjstk '2)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 107) a3)
106
(push a3)
(push a2)
(push (@ 118))
(push (& 4))
(mov '1 a4)
(jmp outchan)
118
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
107
(eval ())
(adjstk '1)
(push (@ 119))
(mov '0 a4)
(jmp inchan)
119
(eval ())
(push a1)
(push (@ 120))
(push dlink)
(push prot)
(stack dlink)
(push (@ 122))
(push (cvalq *trace-input*))
(mov '1 a4)
(jmp inchan)
122
(eval ())
(jcall teread)
(jcall readline)
(mov (car a1) a4)
(mov (& 1) dlink)
(adjstk '3)
(push a4)
(mov (@ 121) a3)
120
(push a3)
(push a2)
(push (@ 123))
(push (& 4))
(mov '1 a4)
(jmp inchan)
123
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
121
(eval ())
(adjstk '2)
(bra #:step:steploop)
104
(cabne a1 '61 124)
(push 't)
(push (cvalq #:system:debug))
(mov (& 1) (cvalq #:system:debug))
(push '1)
(push '(#:system:debug))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 125))
(push 'step)
(push 'break)
(push (cvalq #:step:forme))
(mov '3 a4)
(jmp list)
125
(eval ())
(mov a1 a2)
(mov 'syserror a1)
(jcall itsoft)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:system:debug))
(adjstk '8)
(mov '46 a1)
(adjstk '1)
(bra #:step:steploop)
124
(cabne a1 '60 126)
(push nil)
(push (cvalq #:step:speak))
(mov (& 1) (cvalq #:step:speak))
(push '1)
(push '(#:step:speak))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 127))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp eval)
127
(eval ())
(mov (& 1) dlink)
(mov (& 6) (cvalq #:step:speak))
(adjstk '8)
(mov a1 (cvalq #:step:value))
(push (@ 128))
(mov '0 a4)
(jmp outchan)
128
(eval ())
(push a1)
(push (@ 129))
(push dlink)
(push prot)
(stack dlink)
(push (@ 131))
(push (cvalq *trace-output*))
(mov '1 a4)
(jmp outchan)
131
(eval ())
(mov (cvalq #:step:depth) a1)
(call #:step:stepmargin)
(push (@ 132))
(push (cvalq #:step:depth))
(push '" <- ")
(push (cvalq #:step:value))
(mov '3 a4)
(jmp print)
132
(eval ())
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 130) a3)
129
(push a3)
(push a2)
(push (@ 133))
(push (& 4))
(mov '1 a4)
(jmp outchan)
133
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
130
(eval ())
(adjstk '2)
(return)
126
(cabne a1 '113 134)
(mov nil a1)
(mov '#:system:toplevel-tag a2)
(jmp #:llcp:exit)
(adjstk '1)
(return)
134
(cabne a1 '104 135)
(mov (cvalq #:step:history) a1)
(jcall reverse)
(push '0)
(push (cvalq #:step:history))
(mov a1 (cvalq #:step:history))
(push '1)
(push '(#:step:history))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 136))
(mov '0 a4)
(jmp outchan)
136
(eval ())
(push a1)
(push (@ 137))
(push dlink)
(push prot)
(stack dlink)
(push (@ 139))
(push (cvalq *trace-output*))
(mov '1 a4)
(jmp outchan)
139
(eval ())
140
(btnil (cvalq #:step:history) 141)
(mov (& 11) a1)
(call #:step:stepmargin)
(push (@ 142))
(mov (& 12) a1)
(jcall |1+|)
(mov a1 (& 12))
(push a1)
(push '" ")
(mov (cvalq #:step:history) a4)
(mov (cdr a4) (cvalq #:step:history))
(push (car a4))
(mov '3 a4)
(jmp print)
142
(eval ())
(bra 140)
141
(mov nil a4)
(mov (& 1) dlink)
(adjstk '3)
(push a4)
(mov (@ 138) a3)
137
(push a3)
(push a2)
(push (@ 143))
(push (& 4))
(mov '1 a4)
(jmp outchan)
143
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
138
(eval ())
(adjstk '1)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:step:history))
(adjstk '8)
(mov '46 a1)
(adjstk '1)
(bra #:step:steploop)
135
(cabne a1 '63 144)
(push (@ 145))
(mov '0 a4)
(jmp outchan)
145
(eval ())
(push a1)
(push (@ 146))
(push dlink)
(push prot)
(stack dlink)
(push (@ 148))
(push (cvalq *trace-output*))
(mov '1 a4)
(jmp outchan)
148
(eval ())
(push (@ 149))
(mov '#:step:help1 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
149
(eval ())
(push (@ 150))
(mov '#:step:help2 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
150
(eval ())
(push (@ 151))
(mov '#:step:help3 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
151
(eval ())
(push (@ 152))
(mov '#:step:help4 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
152
(eval ())
(push (@ 153))
(mov '#:step:help5 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
153
(eval ())
(push (@ 154))
(mov '#:step:help6 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
154
(eval ())
(push (@ 155))
(mov '#:step:help7 a1)
(jcall get-message)
(push a1)
(mov '1 a4)
(jmp print)
155
(eval ())
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 147) a3)
146
(push a3)
(push a2)
(push (@ 156))
(push (& 4))
(mov '1 a4)
(jmp outchan)
156
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
147
(eval ())
(adjstk '1)
(mov '46 a1)
(adjstk '1)
(bra #:step:steploop)
144
(push (@ 158))
(mov '0 a4)
(jmp outchan)
158
(eval ())
(push a1)
(push (@ 159))
(push dlink)
(push prot)
(stack dlink)
(push (@ 161))
(push (cvalq *trace-output*))
(mov '1 a4)
(jmp outchan)
161
(eval ())
(bfcons (cvalq #:step:forme) 162)
(mov (cvalq #:step:forme) a4)
(cabne (car a4) 'send 162)
(push (@ 166))
(push (cvalq #:sys-package:tty))
(push 'tyi)
(mov '2 a4)
(jmp getfn)
166
(eval ())
(jcall valfn)
(push a1)
(push (@ 167))
(mov 'tyi a1)
(jcall valfn)
(push a1)
(mov '#:tty:tyi a1)
(jcall valfn)
(push a1)
(mov '2 a4)
(jmp list)
167
(eval ())
(mov a1 a2)
(pop a1)
(jcall member)
(btnil a1 164)
(push (@ 168))
(push dlink)
(push prot)
(stack dlink)
(push nil)
(push nil)
(push (cvalq #:trace:windowp))
(mov (& 1) (cvalq #:trace:windowp))
(push '1)
(push '(#:trace:windowp))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(mov '((send (entry (setq #:step:fnt (getfn (type-of (cadr #:trace:arg1)) (car #:trace:arg1))) (cond ((null #:step:fnt)) ((or (memq #:step:fnt #:trace:untracable) (memq #:step:fnt '(car print prin)))) (t (#:trace:trace-one (cons #:step:fnt '((step t))))))) (exit (if (memq #:step:fnt #:trace:trace) (#:trace:untrace-one #:step:fnt))))) a1)
(jcall trace)
(push nil)
(push (cvalq #:step:speak))
(mov (& 1) (cvalq #:step:speak))
(push '1)
(push '(#:step:speak))
(push 'lambda)
(push llink)
(push dlink)
(push cbindn)
(stack dlink)
(push (@ 170))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp #:trace:eval)
170
(eval ())
(mov (& 1) dlink)
(mov (& 6) (cvalq #:step:speak))
(adjstk '8)
(mov (& 1) dlink)
(mov (& 6) (cvalq #:trace:windowp))
(adjstk '9)
(mov (& 1) dlink)
(adjstk '3)
(push a1)
(mov (@ 169) a3)
168
(push a3)
(push a2)
(mov (cvalq #:trace:trace) a2)
(mov 'send a1)
(jcall memq)
(btnil a1 172)
(mov '(send) a1)
(jcall untrace)
172
(pop a2)
(pop a3)
(pop a1)
(bri a3)
169
(eval ())
(mov a1 a4)
(bra 163)
164
(mov (cvalq #:step:depth) a1)
(call #:step:stepmargin)
(mov (cvalq #:step:forme) a3)
(mov '#:step:errnosendwindow a2)
(mov 'step a1)
(jcall printerror)
(push (@ 173))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp eval)
173
(eval ())
(mov a1 a4)
(bra 163)
162
(mov (cvalq #:step:forme) a1)
(call #:step:nobind?)
(btnil a1 174)
(mov (cvalq #:step:depth) a1)
(call #:step:stepmargin)
(mov (cvalq #:step:forme) a3)
(mov '#:step:errnonobind a2)
(mov 'step a1)
(jcall printerror)
(push (@ 176))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp eval)
176
(eval ())
(mov a1 a4)
(bra 163)
174
(push (@ 177))
(push (cvalq #:step:forme))
(push (cvalq #:step:env))
(mov '2 a4)
(jmp traceval)
177
(eval ())
(mov a1 a4)
163
(mov a4 (cvalq #:step:value))
(mov (& 1) dlink)
(adjstk '3)
(push a4)
(mov (@ 160) a3)
159
(push a3)
(push a2)
(push (@ 178))
(push (& 4))
(mov '1 a4)
(jmp outchan)
178
(eval ())
(pop a2)
(pop a3)
(pop a1)
(bri a3)
160
(eval ())
(adjstk '1)
(mov (cvalq #:step:depth) a1)
(call #:step:stepmargin)
(push (@ 179))
(push (cvalq #:step:depth))
(push '" <- ")
(push (cvalq #:step:value))
(mov '3 a4)
(jmp print)
179
(eval ())
(adjstk '1)
(return)
))
(loader'((fentry stepend subr0)
(entry stepend subr0)
(push (@ 101))
(push 'step)
(mov '1 a4)
(jmp oblist)
101
(eval ())
(push a1)
102
(bfcons (& 0) 103)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(jcall remob)
(bra 102)
103
(adjstk '1)
(mov '(trace step unstep cstep) a1)
(jcall libautoload)
(mov 'stepend a1)
(return)
))
(loader'((fentry tracend subr0)
(entry tracend subr0)
(mov '() a1)
(jcall untrace)
(push (@ 101))
(push 'trace)
(mov '1 a4)
(jmp oblist)
101
(eval ())
(push a1)
102
(bfcons (& 0) 103)
(mov (& 0) a1)
(mov (cdr a1) (& 0))
(mov (car a1) a1)
(jcall remob)
(bra 102)
103
(adjstk '1)
(mov '(trace trace untrace) a1)
(jcall libautoload)
(mov 'tracend a1)
(return)
))
(loader'((fentry debugend subr0)
(entry debugend subr0)
(jcall tracend)
(jcall stepend)
(mov 'debug a1)
(jcall rem-feature)
(mov 'debugend a1)
(return)
))
(loader '((end)))

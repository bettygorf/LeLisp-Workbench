;;; $Id$
;;;
;;; to fabricate makefile : prjname.make
;;;

(setq #:sys-package:colon 'rtproject)

;; with of makefile
(defvar :makefile:rmargin
  (if (boundp ':makefile:rmargin) :makefile:rmargin 60))
;; to compile .ll files
(defvar :complice-command
  (if (boundp ':complice-command)
      :complice-command
    "$(LLDIR)$(SYSTEM)/complice"))
;; verbose flag
(defvar :verbose-makefile
  (if (boundp ':verbose-makefile) :verbose-makefile (gt #:crunch:verbose 0)))
;; module's extension 
(defvar :extension ())

(defun :build-make (output prj)
  (let ((fmake (or output (:make-file prj)))
	(fpath (catenate (:name prj) ".pth"))
	(:verbose-makefile (gt #:crunch:verbose 0))
	)
    (#:crunch:save-file fmake)
    (with ((outchan (openo fmake))
	   (rmargin (add1 (slen (outbuf)))) )
	  (protect (:print-modules-makefile prj)
		   (close (outchan))) )

    (#:crunch:save-file fpath)
    (with ((outchan (openo fpath))
	   (rmargin (add1 (slen (outbuf)))) )
	  (protect (print "(setq #:system:path (append #:system:path '(")
		   (let ((#:system:print-for-read t))
		     (mapc (lambda(p) (print (namestring p)))
			   (list-complice-directories prj))
		     )
		   (print ")))")
		   (close (outchan))) )

    ))

#|===========================================================================
   Make modules & complice
---------------------------------------------------------------------------|#

(defun :print-modules-makefile (project)
   (let ((data (mapcar 'car
		       ({llmodulereferences}:modulesimport (current-mr))))
         (targetdir (get-system-directory project))
         (lodir (get-main-ll-object-directory project))
         (lmdir (get-main-ll-module-directory project))
         ;; *** Warning : the latter "" is important, because
         ;; some pathnames are absolute.
         ;!oups KESCEKE C KECA?!?! :path a ete mis a jour par :step1
	 ;(#:system:path (nconc1 (list-rt-directories project) ""))
	 lcd slodir slmdir
         )
     
     ;; eventualy we play with save-extension
     (setq :extension (:module-extension project))

     ;; header...
     (print "# This makefile was generated by the ILOG Analyzer.")
     (print "# Version     : " #:crunch:version "         Date : " (date))
     (print "# SubVersion  : " #:crunch:subversion)
     (print "# It enables to build modules from Lisp source files for ")
     (print "# - project : " (:name project))
     (print "#")

     (when (gt #:crunch:verbose 1)
	   (let ((#:sys-package:itsoft (cons ':makefile:comment
					     #:sys-package:itsoft)))
	     (prin "# ")
	     (terpri)
	     (terpri)
	     (pprint project))
	   (terpri))
     
     (print "######")
     (print "# Directories")
     (print "######")
     (terpri)
     (:print-env "ROOTDIR" (namestring (or (:root-directory project) "./")))
     (:print-env "SYSTEM" (string (system)))
     (:print-env "LLDIR" (namestring rt-lelisp-directory))
     (when lodir
	   (setq slodir (namestring lodir))
	   (:print-env "LLOBJDIR" slodir)
	   (setq lodir "$(LLOBJDIR)"))
     (when lmdir
	   (setq slmdir (namestring lmdir))
	   (:print-env "LLMODDIR" slmdir)
	   (setq lmdir "$(LLMODDIR)"))
     (:print-env "TOUCH" "touch")
     (:print-env "CP" "cp")
     (terpri)

     (print "######")
     (print "# Make use of standard complice")
     (print "######")
     (terpri)
     (:print-env "COMPLICE" :complice-command)
     (terpri)
     
     (print "######")
     (print "# Complice options")
     (print "######")
     (terpri)
     (print "USERFLAGS=")
     (print "#COMPLICEOPT=-hh")
     (prin "COMPLICEFLAGS=")
     (:prinf 
      `("$(COMPLICEOPT)" 
	,@(when (gt #:crunch:verbose 1) `("-v"))
	"-e ""(set (symbol (quote system)(quote path)) (list "
	"\""\"""
	"\""$(LLDIR)$(SYSTEM)/\"""
	,.(mapcar (lambda(p)
		    (setq p (namestring p))
		    (cond
		     ((and lmdir (equal p slmdir))
		      "\""$(LLMODDIR)\""")
		     ((and lodir (equal p slodir))
		      "\""$(LLOBJDIR)\""")
		     (t
		      (catenate "\""" p "\""")) ))
		  (list-complice-directories project))
	"))"""
	,@(cassoc "all" (:complice-options project))
	"$(USERFLAGS)"
	))
     (terpri 2)
     
     ;; now printing all modules .lo for that project
     (print "######")
     (print "# LL Objects involved")
     (print "######")
     (terpri)
     (prin "LLOBJS=")
     (:prinf (mapcar (lambda (x) (namestring (:make-object-filename x lodir)))
		     data))
     (terpri 2)
     
     ;; print module dependancy
     (print "######")
     (print "# Generic entries")
     (print "######")
     (terpri)
     (print "all : $(LLOBJS)")
     (terpri)
     (print "clean :")
     (princn #\TAB)
     (print "rm -f $(LLOBJS)")
     (terpri 2)
     (print "info :")
     (princn #\TAB)
     (print "@echo complice=$(COMPLICE)")
     (princn #\TAB)
     (print "@echo compliceflags=$(COMPLICEFLAGS)")
     (terpri)
     (print "i :")
     (princn #\TAB)
     (prinf "@$(COMPLICE) $(COMPLICEFLAGS) -v -i")
     (terpri 2)
     
     ;; 
     ;; COMPLICE dependencies
     ;; 
     (print "######")
     (print "# Module dependencies")
     (print "######")
     (terpri)
     (mapc (lambda (x)
	     (:print-complice-command
	      x
	      (:print-lo-dependencies project x lodir lmdir)
	      (cassoc x (:complice-options project))
	      lodir
	      lmdir))
	   data)
     (terpri)
     ))

;;;;;;
;;; Lisp source / LL module (.lo) dependencies
;;;;;;
(defvar :defmod)
(defun :print-lo-dependencies (project x lodir lmdir)
  (let ((lm (if lmdir (catenate lmdir x #:system:mod-extension)
	      (probepathm x)))
        (lo  (:make-object-filename x lodir))
	:defmod
	)
    (if lm
        (let ((lc (when :extension
			(let ((#:system:mod-extension
			       (catenate "." :extension)))
			  (probepathm x))))
	      )
	  (setq :defmod (readdefmodule x))
	  ;; if exist, copy .lc to .lm
	  (when lc
		(setq lc (namestring lc))
		(:prinf `(,lm ":" ,lc))
		(terpri)
		(princn #\TAB)
		(:prinf `(,@(unless :verbose-makefile '("@"))
			  "$(CP) " ,lc " " ,lm))
		(terpri))
	  ;; target line
	  (let ((plo (namestring lo))
		(flo (catenate x #:system:obj-extension)) )
	    (:prinf `(,plo
		      ,@(when (nequal plo flo) (ncons flo))
		      ":")) )
	  ;; dependencies line
          (:prinf
	   `(;; minimal dependancy : file.lm + file(s).ll + include(s).ll
	     ,lm
	     ,.(mapcan (lambda (f)
			 (let ((ll (probepathf f)))
			   (if ll (ncons (namestring ll))
			     (:warning 26 f)())))
		       (append (getdefmodule :defmod 'files)
			       (getdefmodule :defmod 'include)) )

	     ;; dependancy level 1 : localimport.lm
	     ;;            level 2 : localimport.lo
	     ;;            level 3 : allimport.lm
	     ;;            level 4 : allimport.lo
	     ,.(when (gt #:crunch:dependancy 0)
		     (mapcan (lambda(m)
			       (if (or (eqn #:crunch:dependancy 1)
				       (eqn #:crunch:dependancy 3))
				   (let ((lm (:make-output-filename
					      m
					      lmdir
					      (substring #:system:mod-extension
							 1)
					      'probepathm)))
				     (if lm (ncons (namestring lm))
				       (:warning 26 m) ()))
                                 (ncons (namestring
					 (:make-object-filename m lodir)))
                                 ))
			     (if (le #:crunch:dependancy 2)
				 (intersection(getdefmodule :defmod 'import)
					      #:crunch:all-modules)
			       (getdefmodule :defmod 'import))))
	     )
	   )
          (terpri) )
      (#:crunch:error 26 x))
    lo))

;;;;;;
;;; Print the makeentry to build the .lo
;;;;;;

(defun :print-complice-command (mod obj options lodir lmdir)
  ;; mod -> name of .lm [type STRING]
  ;; obj -> complete makefile's path of .lo [type PATHNAME]
  ;; options -> complice's options for that module [type LIST of STRING]
  ;; lodir -> path of .lo or () [type STRING or NULL]
  ;; lmdir -> path of .lm or () [type STRING or NULL]
  (let ((lm (namestring (if lmdir
			    (catenate lmdir mod #:system:mod-extension)
			  (probepathm mod))))
	(lo (namestring obj))
	lc
	)
    (princn #\TAB)
    (:prinf (list "@echo ""+++++ COMPLICE : """ lm))
    (terpri)

    (princn #\TAB)
    (:prinf `(,@(unless :verbose-makefile '("@"))
	      "$(COMPLICE)"
	      ,mod
	      "$(COMPLICEFLAGS)"
	      ,.(if (or lodir (pathname-directory obj))
		    (ncons (catenate "-o "
				     (or lodir (directory-namestring obj)))))
	      ,@options
	      ))
    (terpri)
; est-ce vraiment utile?
;    (princn #\TAB)(:prinf `("@$(TOUCH) " ,lm))(terpri)
;    (princn #\TAB)(:prinf `("@$(TOUCH) " ,lo))(terpri)
    (terpri )
    ))

;;;;;;
;;; Formatted print : try to matrix print an item list, and print a
;;; separator \ if the end of line is reached.
;;;;;;

(defun :prinf (strings)
  (let (string)
    ;; formatted print...
    (while strings
      ;; [ECA] 09/03/93 test added to avoid processing strings containing only
      ;; spaces (because in some cases, it can cause an appended "\"
      ;; followed by a blank line, and blank lines are ignored in makefiles;
      ;; thus, the appended "\" is misunderstood by the system and applies to
      ;; the following line)
      (setq string (string (nextl strings)))
      (if (spanstring string " ")
          (progn
            (if (gt (add (slen string) (outpos)) :makefile:rmargin)
                (progn
                  (princn #/\ )
                  (terpri)
                  (princn #\TAB)))
            (prin string)
            (princn 32))))))


#|===========================================================================
   Some utilities
---------------------------------------------------------------------------|#

;;;;;;
;;; Return one object file
;;;;;;

(defun :make-object-filename (name lodir)
  (:make-output-filename name lodir "lo" 'probepathm))

;;;;;;
;;; Build a output file specification, for a given file type and 
;;; default directory
;;;;;;

(defun :make-output-filename (name lodir extension probef)
  (let ((pn (merge-pathnames #p"" (pathname name))));copy-pathname
    (set-pathname-type pn extension)
    (if lodir
	(if (pathnamep lodir)
	    (merge-pathnames lodir pn)
	  (catenate lodir (file-namestring pn)))
      (combine-pathnames
       (let ((pb (catcherror t (pathname (funcall probef name)))))
	 (or (car pb)
	     (#:crunch:error 26 name)))
       pn) )))

;;; return module name with good path (from lmdir or file .ll path)
(defun :make-module-filename (name lmdir)
  (:make-output-filename name
			 lmdir
			 (substring #:system:mod-extension 1)
			 'probepathf))

(defvar :sed-values)

(defun :declare-sed-value (old new)
  (let ((pair (assoc old :sed-values)))
    (if pair
        (rplacd pair new)
      (setq :sed-values (acons old new :sed-values)))
    old))

(defun :print-env (varname value)
  (print varname "=" value)
  (:declare-sed-value varname value))

(defvar :sed-marker "SEDMARKER")

(defvar #:rtproject:sed-file-p
  (if (boundp '#:rtproject:sed-file-p) #:rtproject:sed-file-p t))

(defun :makefile:comment:eol ()
  (super-itsoft ':makefile:comment 'eol ())
  (outbuf 0 #/#)
  (outbuf 1 32)
  (outpos 2))

(defmacro :warning l
  `(with ((outchan ()))
	 (#:crunch:warning ,@l)))
